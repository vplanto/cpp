# Методологічні рекомендації до курсу C++ (1-й курс)

**Джерело:** Обговорення спільноти r/cpp "Course program for 1st year students".

## 1. Педагогічні стратегії (How to Teach)

### Project-Based Learning: "Coffee Machine" Pattern

Ефективний спосіб пояснити необхідність OOP — не давати теорію одразу, а симулювати реальний робочий процес:

* **Крок 1:** Дати завдання реалізувати "toy project" (наприклад, кавомашину) будь-яким способом.
* **Крок 2:** Різко змінити вимоги і попросити імплементувати зміни "на вчора".
* **Крок 3:** Повторювати зміну вимог, поки студент не усвідомить біль "спагетті-коду". Тільки тоді вводити патерни та OOP як рятівний інструмент.

### Візуалізація пам'яті (Memory First)

Для розуміння вказівників та пам'яті (Stack vs Heap) рекомендується "low-level" вправа до переходу на smart pointers:
* Оголосити великий масив `char*` як "сиру пам'ять".
* Призначати вказівники на структури (structs) всередині цього регіону та робити кастинг між ними.
* Це формує ментальну модель того, що реально відбувається в RAM, що є критичним для C++ програміста.

### Iterators First

* Викладати ітератори на ранніх етапах як спосіб доступу до стандартних алгоритмів контейнерів.

## 2. Технічний стек та Архітектура (Technical Scope)

### OOP & Inheritance (Best Practices)

* **Public Inheritance:** Пояснювати через принципи SOLID: **LSP** (Liskov Substitution Principle) як причину існування поліморфізму та **OCP** (Open/Closed Principle).
* **Slicing Danger:** В публічних ієрархіях у 95% випадків копіювання та move мають бути заборонені (`deleted`), щоб уникнути зрізання об'єктів (slicing).
* **Multiple Inheritance:** Не викладати новачкам, якщо немає реальної практичної задачі. У більшості випадків це "contrived taxonomy bullshit", яке краще викинути з курсу.
* **Private Inheritance:** Пояснювати як механізм "Implemented-in-terms-of" (на відміну від "Substitutable-to" у публічному успадкуванні).

### Modern C++ Specifics

* **Templates:** Пояснити концепцію, що кожен шаблонний параметр створює абсолютно новий тип. Акцент на виведенні типів (type deduction).
* **Rule of Five:** Можна пропустити або дати оглядово. Професійні розробники (5+ років досвіду) рідко пишуть це вручну в сучасному C++.
* **Smart Pointers:** Пояснювати разом з семантикою переміщення (Move Semantics) та володінням (Ownership). Різниця `unique` vs `shared`.

## 3. Tooling & Environment (Engineering Culture)

* **TDD (Test Driven Development):** Вводити Google Test якомога раніше. Привчати писати тести для домашніх завдань.
* **CMake:** Використовувати з самого початку. Це стандарт індустрії, і він корисний для налаштування тестів.
* **Compiler Errors:** Окремо вчити читати помилки компілятора. Особливу увагу приділити помилкам, пов'язаним з `const`-кваліфікаторами.

## 4. Типові больові точки студентів (Pain Points)

Список тем, де студенти "буксують" найчастіше:

* **Const correctness:** Різниця між Top-level const та Low-level const.
* **Initialization:** Коли використовувати `T()` проти `T{}`.
* **Operator Precedence:** Правило: "when in doubt, use parentheses".
* **Access Rules:** Взаємодія `private`/`protected`/`public` при різних типах успадкування.
* **Type Deduction:** Розуміння, який тип вивів компілятор у шаблонах.