# Лекція 15: Правило Трьох, Deep Copy та Перевантаження Операторів

[← Лекція 14](14_raii_lifecycle.md) | [Index](index.md) | [Далі: Лекція 16 →](16_inheritance_polymorphism.md)


## Мета
Зрозуміти найнебезпечнішу пастку C++ — **Shallow Copy** (поверхневе копіювання) і навчитися її уникати через "Святу Трійцю": Деструктор, Копі-Конструктор, Оператор Присвоєння.

## Експрес-опитування
1.  У чому різниця між `A a = b;` та `a = b;`?
2.  Якщо у класі є вказівник `int* data`, що станеться, якщо скопіювати цей об'єкт "як є" (побітово)?
3.  Що таке `self-assignment` (присвоєння самому собі) і чому це може вбити вашу програму?

<details markdown="1">
<summary>Інженерна відповідь</summary>

1.  `A a = b;` — це **Створення** нового об'єкта (викликається Copy Constructor). `a = b;` — це **Зміна** вже існуючого об'єкта (викликається Copy Assignment Operator).
2.  **Double Free Error.** Обидва об'єкти будуть вказувати на одну й ту ж пам'ять. Коли деструктори спрацюють, вони спробують видалити цю пам'ять двічі.
3.  Це коли ми пишемо `a = a`. Якщо ваш оператор присвоєння спочатку видаляє стару пам'ять, а потім намагається копіювати з неї — ви отримаєте краш.

</details>

---

## Частина 1: Проблема Shallow Copy (Чому програма падає?)

Уявимо наш клас з динамічною пам'яттю (RAII з Лекції 14):

```cpp
class Buffer {
    int* ptr;
public:
    Buffer(int value) { ptr = new int(value); }
    ~Buffer() { delete ptr; }
};

void crashTest() {
    Buffer b1(10);
    Buffer b2 = b1; // Тут компілятор робить побітову копію!
} // Тут b2.dtor видаляє пам'ять. Потім b1.dtor видаляє ту ж пам'ять -> CRASH!

```

Це називається **Shallow Copy**. Вказівники скопіювалися, але дані — ні. Два власники на один ресурс.

---

## Частина 2: Copy Constructor (Клонування)

Щоб виправити це, ми маємо навчити C++ правильно клонувати наш об'єкт. Це називається **Deep Copy**.

**Синтаксис:** `ClassName(const ClassName& other)`

```cpp
class Buffer {
    int* ptr;
public:
    Buffer(int value) { ptr = new int(value); }
    ~Buffer() { delete ptr; }

    // Copy Constructor: Виділяємо НОВУ пам'ять
    Buffer(const Buffer& other) {
        std::cout << "Copying...\n";
        // 1. Беремо значення з іншого об'єкта
        int val = *(other.ptr);
        // 2. Виділяємо СВОЮ власну пам'ять
        ptr = new int(val);
    }
};

```

Тепер `Buffer b2 = b1;` створить повну незалежну копію.

---

## Частина 3: Operator Overloading (Вступ)

В C++ оператори (`+`, `-`, `=`, `<<`) — це просто функції зі смішними іменами.
`a + b` перетворюється на `a.operator+(b)`.

Ми можемо навчити наші класи поводитися як вбудовані типи.

```cpp
class Point {
    int x, y;
public:
    Point(int x, int y) : x(x), y(y) {}

    // Перевантаження +
    Point operator+(const Point& other) {
        return Point(this->x + other.x, this->y + other.y);
    }
};

Point p1(1, 2), p2(3, 4);
Point p3 = p1 + p2; // Працює!

```

---

## Частина 4: Copy Assignment Operator (Найскладніший бос)

Тепер про `a = b`. Це не створення. Це **перезапис**.
Тут діє алгоритм:

1. Перевірити, чи не присвоюємо ми об'єкт самому собі (`if (this == &other)`).
2. **Звільнити** старий ресурс (ми ж його перезаписуємо!).
3. **Виділити** новий ресурс.
4. Скопіювати дані.
5. Повернути `*this` (щоб можна було писати `a = b = c`).

```cpp
// Усередині class Buffer
Buffer& operator=(const Buffer& other) {
    // 1. Self-assignment check
    if (this == &other) {
        return *this; // Нічого робити не треба
    }

    // 2. Звільняємо старе
    delete ptr;

    // 3. & 4. Виділяємо і копіюємо нове (Deep Copy)
    ptr = new int(*(other.ptr));

    // 5. Повертаємо посилання на себе
    return *this;
}

```

---

## Частина 5: The Rule of Three (Закон)

Якщо вашому класу потрібно вручну керувати ресурсом (писати Деструктор), ви **ЗОБОВ'ЯЗАНІ** реалізувати всі три методи:

1. **Destructor** (щоб звільнити ресурс).
2. **Copy Constructor** (щоб не було shallow copy при створенні).
3. **Copy Assignment Operator** (щоб не було shallow copy при присвоєнні).

Якщо ви напишете тільки деструктор — ваша програма впаде при копіюванні.

> **Modern C++ Note:** Якщо ви не хочете морочитися з копіюванням, просто забороніть його:
> `Buffer(const Buffer&) = delete;`
> `Buffer& operator=(const Buffer&) = delete;`
> Це називається `NonCopyable` ідіома (використовується в `std::unique_ptr`).

---

## Контрольні питання

1. Напишіть прототип Copy Constructor для класу `String`.
2. Чому в операторі присвоєння (`operator=`) ми повертаємо `String&`, а не `void`?
3. Що станеться в `operator=`, якщо ми забудемо перевірку `if (this == &other)` і напишемо `a = a`? (Підказка: ми спочатку зробимо `delete`, а потім спробуємо читати з видаленої пам'яті).
4. Які оператори НЕ МОЖНА перевантажити? (Відповідь: `.`, `::`, `sizeof`, `?:`).

<details markdown="1">
<summary>Відповіді</summary>

1. `String(const String& other);`
2. Щоб підтримувати ланцюжок присвоєнь: `a = b = c;`. Це еквівалентно `a.operator=(b.operator=(c));`.
3. **Undefined Behavior / Crash.** Ми видалимо власні дані (`delete ptr`), а потім спробуємо скопіювати дані з `other.ptr` (який є тим самим `ptr`, що ми щойно видалили).
4. Оператор доступу до члена (`.`), Scope resolution (`::`), тернарний (`?:`) та `sizeof`.

</details>
