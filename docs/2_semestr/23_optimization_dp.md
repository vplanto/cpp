# Лекція 23: Стратегії оптимізації — Greedy Algorithms \u0026 Dynamic Programming

[← Лекція 22](22_graphs_search.md) | [Index](index.md)

## Мета

Зрозуміти, коли жадібні алгоритми (Greedy) працюють, а коли потрібне Dynamic Programming (DP). Навчитися розв'язувати задачу про рюкзак (Knapsack Problem). Розуміти принцип мемоїзації.

## Експрес-опитування

1. У вас є монети номіналом 1, 5, 10, 25 центів. Щоб дати здачу 30 центів, жадібний алгоритм (завжди бери найбільшу монету) дасть правильну відповідь?
2. Чи можна розв'язати будь-яку оптимізаційну задачу жадібним алгоритмом?
3. Що таке мемоїзація (memoization)?

<details markdown="1">
<summary>Інженерна відповідь</summary>

1. **Так.** Жадібний алгоритм: 25 + 5 = 30 (2 монети). Це оптимально. Але для інших наборів монет (наприклад, 1, 3, 4) жадібний алгоритм може дати неоптимальну відповідь.
2. **Ні.** Greedy працює тільки тоді, коли задача має властивість "Greedy Choice Property" — локально оптимальний вибір веде до глобального оптимуму. Для задач, де потрібно врахувати майбутні наслідки, потрібен DP.
3. **Запам'ятовування вже обчислених результатів,** щоб не рахувати їх повторно. Це основа DP — ми зберігаємо проміжні результати у таблиці (або масиві).

</details>

---

## Частина 1: Greedy Algorithms — коли жадібність працює

**Ідея:** На кожному кроці робити локально найкращий вибір, сподіваючись, що це призведе до глобального оптимуму.

### Приклад 1: Coin Change (для певних наборів монет)

Задача: Дати здачу N центів мінімальною кількістю монет.

Набір монет: `{1, 5, 10, 25}` (центи США).

```cpp
#include <vector>
#include <iostream>

int greedyCoinChange(int amount, const std::vector<int>& coins) {
    int count = 0;
    
    // Монети повинні бути відсортовані за спаданням
    for (int coin : coins) {
        while (amount >= coin) {
            amount -= coin;
            count++;
            std::cout << coin << " ";
        }
    }
    
    std::cout << "\\nTotal coins: " << count << "\\n";
    return count;
}

int main() {
    std::vector<int> coins = {25, 10, 5, 1};
    greedyCoinChange(63, coins); // Виведе: 25 25 10 1 1 1 (6 монет)
}
```

**Чому це працює для {1, 5, 10, 25}?**
Ці номінали спеціально підібрані так, що жадібний вибір завжди оптимальний. Це називається **Canonical Coin System**.

### Приклад 2: Activity Selection (вибір максимальної кількості занять)

Задача: У вас є N занять з часом початку та кінця. Виберіть максимальну кількість занять, які не перетинаються.

**Greedy Strategy:** Завжди вибирайте заняття, яке **закінчується найраніше**.

```cpp
#include <vector>
#include <algorithm>

struct Activity {
    int start, finish;
};

int activitySelection(std::vector<Activity>& activities) {
    // Сортуємо за часом закінчення
    std::sort(activities.begin(), activities.end(), 
              [](const Activity& a, const Activity& b) {
                  return a.finish < b.finish;
              });
    
    int count = 1;
    int lastFinish = activities[0].finish;
    
    for (int i = 1; i < activities.size(); i++) {
        if (activities[i].start >= lastFinish) {
            count++;
            lastFinish = activities[i].finish;
        }
    }
    
    return count;
}
```

**Чому це працює?**
Вибираючи заняття, яке закінчується найраніше, ми залишаємо максимум часу для наступних занять.

---

## Частина 2: Коли Greedy НЕ працює

### Антиприклад: Coin Change для {1, 3, 4}

Дати здачу 6 центів.

- **Greedy:** 4 + 1 + 1 = **3 монети** (suboptimal).
- **Optimal:** 3 + 3 = **2 монети**.

Жадібний алгоритм вибрав 4 (найбільшу), але це не призвело до оптимуму.

**Висновок:** Greedy працює не завжди. Для таких задач потрібен **Dynamic Programming**.

---

## Частина 3: Dynamic Programming — ідея

DP розбиває задачу на **підзадачі**, розв'язує їх один раз і **запам'ятовує результати** (memoization).

### Принципи DP

1. **Optimal Substructure:** Оптимальне рішення задачі складається з оптимальних рішень підзадач.
2. **Overlapping Subproblems:** Підзадачі повторюються багато разів.

### Приклад: Fibonacci (Naive vs DP)

**Naive Recursion (O(2^N)):**
```cpp
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2); // Рахує fib(5) багато разів
}
```

**DP Solution (O(N)):**
```cpp
#include <vector>

int fibDP(int n) {
    if (n <= 1) return n;
    
    std::vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2]; // Використовуємо вже обчислені значення
    }
    
    return dp[n];
}
```

**Ключова ідея:** Замість того, щоб рахувати `fib(5)` кілька разів, ми зберігаємо його у `dp[5]` і використовуємо повторно.

---

## Частина 4: Knapsack Problem — класика DP

Задача: У вас є рюкзак з максимальною вагою W. Є N предметів, кожен має вагу `w[i]` та цінність `v[i]`. Виберіть предмети так, щоб сумарна цінність була максимальною, але вага не перевищувала W.

### 0/1 Knapsack (кожен предмет можна взяти лише раз)

**DP Formula:**
```
dp[i][w] = максимальна цінність для перших i предметів з вагою не більше w

dp[i][w] = max(
    dp[i-1][w],           // Не беремо i-й предмет
    dp[i-1][w - weight[i]] + value[i]  // Беремо i-й предмет
)
```

**Код:**
```cpp
#include <vector>
#include <algorithm>

int knapsack(int W, const std::vector<int>& weights, const std::vector<int>& values) {
    int n = values.size();
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(W + 1, 0));
    
    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= W; w++) {
            // Не беремо предмет i
            dp[i][w] = dp[i-1][w];
            
            // Намагаємося взяти предмет i
            if (weights[i-1] <= w) {
                dp[i][w] = std::max(dp[i][w], 
                                    dp[i-1][w - weights[i-1]] + values[i-1]);
            }
        }
    }
    
    return dp[n][W];
}

int main() {
    std::vector<int> weights = {2, 3, 4, 5};
    std::vector<int> values  = {3, 4, 5, 6};
    int W = 8;
    
    std::cout << "Max value: " << knapsack(W, weights, values) << "\\n"; // 10
}
```

**Складність:** O(N * W) — де N = кількість предметів, W = максимальна вага.

---

## Частина 5: Greedy vs DP — коли що використовувати

| Характеристика | Greedy | Dynamic Programming |
|----------------|--------|---------------------|
| **Складність** | Зазвичай O(N log N) | Зазвичай O(N^2) або O(N * M) |
| **Оптимальність** | Не завжди гарантована | Завжди оптимальне рішення |
| **Пам'ять** | O(1) або O(N) | O(N * M) — таблиця мемоїзації |
| **Приклади де працює Greedy** | Activity Selection, Huffman Coding, Dijkstra | — |
| **Приклади де потрібен DP** | — | Knapsack, Longest Common Subsequence, Coin Change (загальний випадок) |

**Правило:** Спочатку спробуйте Greedy (простіше і швидше). Якщо не працює — переходьте до DP.

---

## Практичне застосування

**Див.:** [Практикум 16: Knapsack Problem](p16_knapsack.md) — реалізація динамічного програмування на задачі про рюкзак.
**Поглиблене вивчення:** [Лекція 26: Tree Data Structures](26_tree_structures.md) — глибоке розуміння BST та Red-Black дерев, механіка балансування.

## Контрольні питання

1. Чому рекурсивний Fibonacci має складність O(2^N)?

<details markdown="1">
<summary>Відповідь</summary>

Кожен виклик `fib(n)` породжує 2 виклики (`fib(n-1)` та `fib(n-2)`). Це створює бінарне дерево викликів висотою N, де кількість вузлів ~2^N. Більшість викликів повторюються (наприклад, `fib(5)` обчислюється багато разів), але без мемоїзації ми рахуємо їх заново.

</details>

2. У чому різниця між 0/1 Knapsack та Fractional Knapsack?

<details markdown="1">
<summary>Відповідь</summary>

- **0/1 Knapsack:** Предмет можна взяти повністю або не брати взагалі. Потрібен DP (O(N*W)).
- **Fractional Knapsack:** Можна брати частини предмета. Тут працює Greedy (сортуємо за value/weight і беремо найвигідніші) — O(N log N).

</details>

3. Як визначити, чи можна розв'язати задачу Greedy алгоритмом?

<details markdown="1">
<summary>Відповідь</summary>

Перевірте дві властивості:
1. **Greedy Choice Property:** Локально оптимальний вибір веде до глобального оптимуму.
2. **Optimal Substructure:** Оптимальне рішення включає оптимальні рішення підзадач.

Якщо обидві виконуються — Greedy може спрацювати. Але довести це математично буває складно, тому найкраще — протестувати на кількох прикладах.

</details>

4. Чому таблиця DP у Knapsack має розмір `(N+1) x (W+1)`?

<details markdown="1">
<summary>Відповідь</summary>

- **N+1 рядків:** Перший рядок `dp[0][...]` = базовий випадок (0 предметів = 0 цінності).
- **W+1 стовпців:** Перший стовпець `dp[...][0]` = базовий випадок (вага рюкзака = 0 → не можемо нічого взяти).

Це дозволяє уникнути перевірок на межі масиву і спрощує логіку.

</details>
