# –õ–µ–∫—Ü—ñ—è 18: Modern C++ ‚Äî Move Semantics, Smart Pointers —Ç–∞ Lambdas

[‚Üê –õ–µ–∫—Ü—ñ—è 17](17_generics_operators.md) | [Index](index.md) | [–î–∞–ª—ñ: –õ–µ–∫—Ü—ñ—è 19 ‚Üí](19_complexity_profiling.md)


## –ú–µ—Ç–∞
–ü–µ—Ä–µ—Å—Ç–∞—Ç–∏ –ø–∏—Å–∞—Ç–∏ —è–∫ —É 1998 —Ä–æ—Ü—ñ.
1.  –ó—Ä–æ–∑—É–º—ñ—Ç–∏ **Move Semantics**: —è–∫ "–≤–∫—Ä–∞—Å—Ç–∏" –¥–∞–Ω—ñ –∑–∞–º—ñ—Å—Ç—å –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è (–æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è —à–≤–∏–¥–∫–æ–¥—ñ—ó).
2.  –û—Å–≤–æ—ó—Ç–∏ **Smart Pointers**: —è–∫ –Ω–∞–∑–∞–≤–∂–¥–∏ –∑–∞–±—É—Ç–∏ –ø—Ä–æ `delete` —Ç–∞ Memory Leaks.
3.  –í–∏–≤—á–∏—Ç–∏ **Lambdas**: —è–∫ –ø–∏—Å–∞—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–∏–π –∫–æ–¥ —É —Å—Ç–∏–ª—ñ Python/JS.

## –ï–∫—Å–ø—Ä–µ—Å-–æ–ø–∏—Ç—É–≤–∞–Ω–Ω—è
1.  –£ —á–æ–º—É —Ä—ñ–∑–Ω–∏—Ü—è –º—ñ–∂ "–ö–æ–ø—ñ—é–≤–∞–Ω–Ω—è–º" —Ñ–∞–π–ª—É —ñ "–ü–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è–º" —Ñ–∞–π–ª—É –Ω–∞ –¥–∏—Å–∫—É? –©–æ —à–≤–∏–¥—à–µ?
2.  –©–æ —Å—Ç–∞–Ω–µ—Ç—å—Å—è, —è–∫—â–æ —Ñ—É–Ω–∫—Ü—ñ—è –≤–∏–∫–∏–Ω–µ `exception`, –∞ –≤–∏ –∑–∞–±—É–ª–∏ –Ω–∞–ø–∏—Å–∞—Ç–∏ `delete` –¥–ª—è —Å–≤–æ–≥–æ –≤–∫–∞–∑—ñ–≤–Ω–∏–∫–∞?
3.  –ß–∏ –º–æ–∂–Ω–∞ –ø–µ—Ä–µ–¥–∞—Ç–∏ —Ñ—É–Ω–∫—Ü—ñ—é —è–∫ –∞—Ä–≥—É–º–µ–Ω—Ç —ñ–Ω—à—ñ–π —Ñ—É–Ω–∫—Ü—ñ—ó?

<details markdown="1">
<summary>–Ü–Ω–∂–µ–Ω–µ—Ä–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å</summary>

1.  **–ü–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è –º–∏—Ç—Ç—î–≤–µ** (–∑–º—ñ–Ω—é—î—Ç—å—Å—è –∑–∞–ø–∏—Å —É —Ç–∞–±–ª–∏—Ü—ñ —Ñ–∞–π–ª–æ–≤–æ—ó —Å–∏—Å—Ç–µ–º–∏). –ö–æ–ø—ñ—é–≤–∞–Ω–Ω—è ‚Äî –¥–æ–≤–≥–µ (—á–∏—Ç–∞–Ω–Ω—è + –∑–∞–ø–∏—Å —É—Å—ñ—Ö –±–∞–π—Ç—ñ–≤). –£ –ø–∞–º'—è—Ç—ñ —Ç–∞–∫ —Å–∞–º–æ.
2.  **Memory Leak.** –ü–∞–º'—è—Ç—å –∑–∞–ª–∏—à–∏—Ç—å—Å—è –∑–∞–π–Ω—è—Ç–æ—é –Ω–∞–∑–∞–≤–∂–¥–∏ (–¥–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫—É –ø—Ä–æ—Ü–µ—Å—É).
3.  –¢–∞–∫, —á–µ—Ä–µ–∑ –≤–∫–∞–∑—ñ–≤–Ω–∏–∫ –Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—é, —Ñ—É–Ω–∫—Ç–æ—Ä –∞–±–æ (—è–∫ –º–∏ —Å—å–æ–≥–æ–¥–Ω—ñ –¥—ñ–∑–Ω–∞—î–º–æ—Å—å) —á–µ—Ä–µ–∑ `lambda` —Ç–∞ `std::function`.

</details>

---

## –ß–∞—Å—Ç–∏–Ω–∞ 1: Move Semantics (R-value References)

–¶–µ –≥–æ–ª–æ–≤–Ω–∞ —Ñ—ñ—á–∞ C++11, —è–∫–∞ –∑—Ä–æ–±–∏–ª–∞ –º–æ–≤—É –∑–Ω–∞—á–Ω–æ —à–≤–∏–¥—à–æ—é.

### –ü—Ä–æ–±–ª–µ–º–∞: –ó–∞–π–≤—ñ –∫–æ–ø—ñ—ó
–£—è–≤—ñ—Ç—å, —â–æ –≤–∏ –ø–æ–≤–µ—Ä—Ç–∞—î—Ç–µ –≤–µ–ª–∏—á–µ–∑–Ω–∏–π `Vector` –∑ —Ñ—É–Ω–∫—Ü—ñ—ó.
```cpp
Vector createHugeVector() {
    Vector v(1000000); // 1. –í–∏–¥—ñ–ª–∏–ª–∏ –ø–∞–º'—è—Ç—å
    return v;          // 2. –°–∫–æ–ø—ñ—é–≤–∞–ª–∏ v —É —Ç–∏–º—á–∞—Å–æ–≤–∏–π –æ–±'—î–∫—Ç (Deep Copy)
                       // 3. –ó–Ω–∏—â–∏–ª–∏ v
}
Vector main_vec = createHugeVector(); // 4. –°–∫–æ–ø—ñ—é–≤–∞–ª–∏ —Ç–∏–º—á–∞—Å–æ–≤–∏–π –æ–±'—î–∫—Ç —É main_vec

```

–ú–∏ –¥–≤—ñ—á—ñ –∫–æ–ø—ñ—é—î–º–æ –º—ñ–ª—å–π–æ–Ω –µ–ª–µ–º–µ–Ω—Ç—ñ–≤, —â–æ–± –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–¥–∞—Ç–∏ —ó—Ö. –¶–µ –±–µ–∑–≥–ª—É–∑–¥–æ.

### –†—ñ—à–µ–Ω–Ω—è: "–ü–æ–≥—Ä–∞–±—É–≤–∞–Ω–Ω—è" (Move)

–ó–∞–º—ñ—Å—Ç—å —Ç–æ–≥–æ, —â–æ–± –∫–æ–ø—ñ—é–≤–∞—Ç–∏ –¥–∞–Ω—ñ, –º–∏ "–∫—Ä–∞–¥–µ–º–æ" –≤–∫–∞–∑—ñ–≤–Ω–∏–∫ –Ω–∞ –¥–∞–Ω—ñ —É —Ç–∏–º—á–∞—Å–æ–≤–æ–≥–æ –æ–±'—î–∫—Ç–∞, —è–∫–∏–π –≤—Å–µ –æ–¥–Ω–æ –∑–∞—Ä–∞–∑ –ø–æ–º—Ä–µ.

–î–ª—è —Ü—å–æ–≥–æ —ñ—Å–Ω—É—î **R-value reference (`&&`)**.

* **L-value (`&`):** –¢–µ, —â–æ –º–∞—î —ñ–º'—è —ñ –∞–¥—Ä–µ—Å—É (–∑–º—ñ–Ω–Ω–∞ `x`). –ú–æ–∂–µ –∂–∏—Ç–∏ –¥–æ–≤–≥–æ.
* **R-value (`&&`):** –¢–∏–º—á–∞—Å–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è (`5`, `x + y`, —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ñ—É–Ω–∫—Ü—ñ—ó). –ñ–∏–≤–µ –ª–∏—à–µ –≤ —Ü—å–æ–º—É —Ä—è–¥–∫—É.

### The Rule of Five (–ü—Ä–∞–≤–∏–ª–æ –ü'—è—Ç–∏)

–î–æ –Ω–∞—à–æ–≥–æ "Rule of Three" –¥–æ–¥–∞—é—Ç—å—Å—è —â–µ –¥–≤–∞ –º–µ—Ç–æ–¥–∏:

```cpp
class Buffer {
    int* data;
    size_t size;
public:
    // 1. Dtor, 2. Copy Ctor, 3. Copy Assign... (—Å—Ç–∞—Ä—ñ)

    // 4. Move Constructor (–ö—Ä–∞–≤—á—É–∫)
    // –ü—Ä–∏–π–º–∞—î —Ç–∏–º—á–∞—Å–æ–≤–∏–π –æ–±'—î–∫—Ç (other)
    Buffer(Buffer&& other) noexcept {
        data = other.data; // 1. –ö—Ä–∞–¥–µ–º–æ —Ä–µ—Å—É—Ä—Å
        size = other.size;
        
        other.data = nullptr; // 2. –ó–∞–º—ñ—Ç–∞—î–º–æ —Å–ª—ñ–¥–∏ (–æ–±–Ω—É–ª—è—î–º–æ –∂–µ—Ä—Ç–≤—É)
        other.size = 0;
    }

    // 5. Move Assignment Operator
    Buffer& operator=(Buffer&& other) noexcept {
        if (this != &other) {
            delete[] data;     // 1. –ó–≤—ñ–ª—å–Ω—è—î–º–æ —Å–≤–æ—î —Å—Ç–∞—Ä–µ
            
            data = other.data; // 2. –ö—Ä–∞–¥–µ–º–æ —á—É–∂–µ
            size = other.size;
            
            other.data = nullptr; // 3. –û–±–Ω—É–ª—è—î–º–æ –∂–µ—Ä—Ç–≤—É
            other.size = 0;
        }
        return *this;
    }
};

```

–¢–µ–ø–µ—Ä `v1 = std::move(v2)` –ø–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç—å –¥–∞–Ω—ñ –∑–∞ O(1).

---

## –ß–∞—Å—Ç–∏–Ω–∞ 2: Smart Pointers (RAII –Ω–∞ —Å—Ç–µ—Ä–æ—ó–¥–∞—Ö)

<details>
<summary>üî¨ <b>Mathematical View:</b> Pointers as Index Functions</summary>

**Memory as Sequence:**

Model memory as a sequence:
$$M = (m_0, m_1, m_2, \dots, m_n)$$

where each $m_i$ is a byte.

**Pointer Definition:**

A pointer $p$ is simply an **index** $i \in \mathbb{N}$:
$$p: () \to \mathbb{N}, \quad p() = i$$

**Dereferencing:**
$$*p = m_{p()}$$

Accessing the value stored at index $p()$.

**Pointer Arithmetic:**
```cpp
int* p = &arr[0];  // p() = i
p + 1;              // p() = i + sizeof(int)
```

This is index arithmetic: $p_{new}() = p() + \text{sizeof}(T)$.

**Example:**
```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* p = arr;  // p() = address of arr[0]

*p      ‚Üí m_{p()} = 10
*(p+1)  ‚Üí m_{p() + 4} = 20  // sizeof(int) = 4 bytes
*(p+2)  ‚Üí m_{p() + 8} = 30
```

**Iterators (Generalized Indices):**

For non-contiguous structures (linked list, tree), we need a **traversal function**:
$$\text{next}: \text{Node} \to \text{Node}$$

An iterator is a pair:
$$\text{Iterator} = (\text{current\_node}, \text{next\_function})$$

Examples:
- Array iterator: $\text{next}(i) = i + 1$ (trivial index increment)
- List iterator: $\text{next}(node) = node \to next$ (follow pointer)
- Tree iterator: $\text{next}(n) = \text{in\_order\_successor}(n)$ (complex tree traversal)

**Why Smart Pointers:**

Raw pointer: Index $p$ with manual lifecycle management  
Smart pointer: $(p, \text{deleter})$ ‚Äî index + automatic cleanup function

When smart pointer goes out of scope:
1. Call $\text{deleter}(p)$ (free memory at index $p$)
2. Set $p = \text{null}$ (invalid index)

**See also:** [Memory Model Glossary](00_memory_model_glossary.md#1-memory--storage-duration) for storage duration.

</details>

–í–∏ –±—ñ–ª—å—à–µ –Ω–µ –ø–æ–≤–∏–Ω–Ω—ñ –ø–∏—Å–∞—Ç–∏ `new` —ñ `delete` –≤—Ä—É—á–Ω—É. –ù—ñ–∫–æ–ª–∏.
–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ `<memory>` –¥–∞—î –Ω–∞–º "—Ä–æ–∑—É–º–Ω—ñ" –æ–±–≥–æ—Ä—Ç–∫–∏.

### 1. `std::unique_ptr<T>` (–ï–∫—Å–∫–ª—é–∑–∏–≤–Ω–∏–π –≤–ª–∞—Å–Ω–∏–∫)

* **–°—É—Ç—å:** "–¶–∏–º –æ–±'—î–∫—Ç–æ–º –≤–æ–ª–æ–¥—ñ—é —Ç—ñ–ª—å–∫–∏ —è".
* **–ö–æ–ø—ñ—é–≤–∞–Ω–Ω—è:** –ó–∞–±–æ—Ä–æ–Ω–µ–Ω–æ (Deleted Copy Ctor).
* **–ü–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è:** –î–æ–∑–≤–æ–ª–µ–Ω–æ (`std::move`).
* **Overhead:** –ù—É–ª—å–æ–≤–∏–π. –¶–µ –ø—Ä–æ—Å—Ç–æ `T*` –ø—ñ–¥ –∫–∞–ø–æ—Ç–æ–º.

```cpp
#include <memory>

void usage() {
    // make_unique - –±–µ–∑–ø–µ—á–Ω–∏–π —Å–ø–æ—Å—ñ–± —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è (C++14)
    std::unique_ptr<Player> p1 = std::make_unique<Player>("Hero");
    
    p1->attack(); // –ü—Ä–∞—Ü—é—î —è–∫ –∑–≤–∏—á–∞–π–Ω–∏–π –≤–∫–∞–∑—ñ–≤–Ω–∏–∫ ->
    
    // std::unique_ptr<Player> p2 = p1; // –ü–û–ú–ò–õ–ö–ê –ö–û–ú–ü–Ü–õ–Ø–¶–Ü–á! –ö–æ–ø—ñ—é–≤–∞–Ω–Ω—è –∑–∞–±–æ—Ä–æ–Ω–µ–Ω–æ.
    std::unique_ptr<Player> p2 = std::move(p1); // –û–ö. p1 —Ç–µ–ø–µ—Ä –ø—É—Å—Ç–∏–π, p2 –≤–æ–ª–æ–¥—ñ—î –¥–∞–Ω–∏–º–∏.
} // p2 –≤–∏—Ö–æ–¥–∏—Ç—å –∑ scope -> –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è delete. –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ.

```

### 2. `std::shared_ptr<T>` (–°–ø—ñ–ª—å–Ω–∞ –≤–ª–∞—Å–Ω—ñ—Å—Ç—å)

* **–°—É—Ç—å:** "–ú–∏ –≤–æ–ª–æ–¥—ñ—î–º–æ —Ü–∏–º —Ä–∞–∑–æ–º". –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î **Reference Counting** (–ª—ñ—á–∏–ª—å–Ω–∏–∫ –ø–æ—Å–∏–ª–∞–Ω—å).
* **–ö–æ–ø—ñ—é–≤–∞–Ω–Ω—è:** –ó–±—ñ–ª—å—à—É—î –ª—ñ—á–∏–ª—å–Ω–∏–∫ `ref_count++`.
* **–ó–Ω–∏—â–µ–Ω–Ω—è:** –ó–º–µ–Ω—à—É—î `ref_count--`. –ü–∞–º'—è—Ç—å –∑–≤—ñ–ª—å–Ω—è—î—Ç—å—Å—è, –∫–æ–ª–∏ –ª—ñ—á–∏–ª—å–Ω–∏–∫ == 0.

---

## –ß–∞—Å—Ç–∏–Ω–∞ 3: Exceptions (–û–±—Ä–æ–±–∫–∞ –ø–æ–º–∏–ª–æ–∫)

–ö–æ–¥–∏ –ø–æ–º–∏–ª–æ–∫ (`return -1`) ‚Äî —Ü–µ –º–∏–Ω—É–ª–µ —Å—Ç–æ–ª—ñ—Ç—Ç—è. –í–æ–Ω–∏ —ñ–≥–Ω–æ—Ä—É—é—Ç—å—Å—è, –≤–æ–Ω–∏ –∑–º—ñ—à—É—é—Ç—å –ª–æ–≥—ñ–∫—É –∑ –æ–±—Ä–æ–±–∫–æ—é –ø–æ–º–∏–ª–æ–∫.

**–ú–µ—Ö–∞–Ω—ñ–∑–º:**

1. **Throw:** –ö–∏–¥–∞—î–º–æ –ø—Ä–æ–±–ª–µ–º—É –≤–≥–æ—Ä—É.
2. **Try-Catch:** –õ–æ–≤–∏–º–æ –ø—Ä–æ–±–ª–µ–º—É —Ç–∞–º, –¥–µ –∑–Ω–∞—î–º–æ, —è–∫ —ó—ó –≤–∏—Ä—ñ—à–∏—Ç–∏.

```cpp
double divide(double a, double b) {
    if (b == 0) throw std::runtime_error("Division by zero!");
    return a / b;
}

void main() {
    try {
        divide(10, 0);
    } 
    catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
}

```

**–ì–æ–ª–æ–≤–Ω–µ –ø—Ä–æ Exceptions:** –í–æ–Ω–∏ –ø—Ä–∞—Ü—é—é—Ç—å —ñ–¥–µ–∞–ª—å–Ω–æ —Ç—ñ–ª—å–∫–∏ –∑ **RAII**.
–Ø–∫—â–æ –≤–∏–¥—ñ–ª–∏—Ç–∏ –ø–∞–º'—è—Ç—å —á–µ—Ä–µ–∑ `new`, –ø–æ—Ç—ñ–º –∫–∏–Ω—É—Ç–∏ `throw`, –∞ `delete` —Å—Ç–æ—ó—Ç—å –Ω–∏–∂—á–µ ‚Äî –±—É–¥–µ –≤–∏—Ç—ñ–∫.
–Ø–∫—â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ `unique_ptr` ‚Äî –≤—ñ–Ω —Å–∞–º –æ—á–∏—Å—Ç–∏—Ç—å—Å—è –ø—ñ–¥ —á–∞—Å –ø–æ–ª—å–æ—Ç—É –≤–∏–∫–ª—é—á–µ–Ω–Ω—è (Stack Unwinding).

---

## –ß–∞—Å—Ç–∏–Ω–∞ 4: Lambdas & Functional Programming

–Ü–Ω–æ–¥—ñ –Ω–∞–º —Ç—Ä–µ–±–∞ –ø–µ—Ä–µ–¥–∞—Ç–∏ —à–º–∞—Ç–æ–∫ –∫–æ–¥—É –≤ —Ñ—É–Ω–∫—Ü—ñ—é (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –∫—Ä–∏—Ç–µ—Ä—ñ–π —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è). –ü–∏—Å–∞—Ç–∏ –æ–∫—Ä–µ–º—É —Ñ—É–Ω–∫—Ü—ñ—é –∞–±–æ —Ñ—É–Ω–∫—Ç–æ—Ä ‚Äî –¥–æ–≤–≥–æ.

**–õ—è–º–±–¥–∞** ‚Äî —Ü–µ –∞–Ω–æ–Ω—ñ–º–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –ø—Ä—è–º–æ –≤ –∫–æ–¥—ñ.
**–°–∏–Ω—Ç–∞–∫—Å–∏—Å:** `[capture](params) { body }`

```cpp
#include <algorithm>
#include <vector>

void lambdaDemo() {
    std::vector<int> v = {1, 5, 2, 4, 3};
    int threshold = 3;

    // –°–æ—Ä—Ç—É—î–º–æ –ø–æ —Å–ø–∞–¥–∞–Ω–Ω—é
    std::sort(v.begin(), v.end(), [](int a, int b) {
        return a > b;
    });

    // Capture list [threshold]: –ó–∞—Ö–æ–ø–ª—é—î–º–æ –∑–º—ñ–Ω–Ω—É —ñ–∑ –∑–æ–≤–Ω—ñ—à–Ω—å–æ–≥–æ —Å–≤—ñ—Ç—É
    auto it = std::find_if(v.begin(), v.end(), [threshold](int x) {
        return x > threshold; 
    });
}

```

`std::function<Ret(Args)>` ‚Äî —Ü–µ —É–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∞ –æ–±–≥–æ—Ä—Ç–∫–∞, —è–∫–∞ –º–æ–∂–µ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ –ª—è–º–±–¥—É, —Ñ—É–Ω–∫—Ç–æ—Ä –∞–±–æ –≤–∫–∞–∑—ñ–≤–Ω–∏–∫ –Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—é.

---

## –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω—ñ –ø–∏—Ç–∞–Ω–Ω—è

1. –©–æ —Ç–∞–∫–µ `std::move`? –ß–∏ –ø–µ—Ä–µ–º—ñ—â—É—î –≤—ñ–Ω –¥–∞–Ω—ñ —Ñ—ñ–∑–∏—á–Ω–æ? (–ü—ñ–¥–∫–∞–∑–∫–∞: –Ω—ñ, —Ü–µ –ø—Ä–æ—Å—Ç–æ –∫–∞—Å—Ç –¥–æ `&&`, —è–∫–∏–π –¥–æ–∑–≤–æ–ª—è—î –≤–∏–±—Ä–∞—Ç–∏ Move Constructor).
2. –ß–æ–º—É `unique_ptr` —à–≤–∏–¥—à–∏–π –∑–∞ `shared_ptr`?
3. –ù–∞–ø–∏—à—ñ—Ç—å –ª—è–º–±–¥—É, —è–∫–∞ –ø—Ä–∏–π–º–∞—î –¥–≤–∞ `int` —ñ –ø–æ–≤–µ—Ä—Ç–∞—î —ó—Ö —Å—É–º—É.
4. –í —á–æ–º—É –Ω–µ–±–µ–∑–ø–µ–∫–∞ `shared_ptr` –ø—Ä–∏ —Ü–∏–∫–ª—ñ—á–Ω–∏—Ö –ø–æ—Å–∏–ª–∞–Ω–Ω—è—Ö (A –ø–æ—Å–∏–ª–∞—î—Ç—å—Å—è –Ω–∞ B, B –Ω–∞ A)? (–ü—ñ–¥–∫–∞–∑–∫–∞: Memory Leak, –¥–ª—è —Ü—å–æ–≥–æ —î `weak_ptr`).

<details markdown="1">
<summary>–í—ñ–¥–ø–æ–≤—ñ–¥—ñ</summary>

1. `std::move(x)` –Ω–µ —Ä—É—Ö–∞—î –±–∞–π—Ç–∏. –í—ñ–Ω –ø—Ä–æ—Å—Ç–æ –∫–∞–∂–µ –∫–æ–º–ø—ñ–ª—è—Ç–æ—Ä—É: "–í–≤–∞–∂–∞–π `x` —Ç–∏–º—á–∞—Å–æ–≤–∏–º –æ–±'—î–∫—Ç–æ–º, –π–æ–≥–æ –º–æ–∂–Ω–∞ –≥—Ä–∞–±—É–≤–∞—Ç–∏". –°–∞–º–∞ —Ä–æ–±–æ—Ç–∞ —Ä–æ–±–∏—Ç—å—Å—è –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ñ.
2. `unique_ptr` –Ω–µ –º–∞—î –æ–≤–µ—Ä—Ö–µ–¥—É (–ø—Ä–æ—Å—Ç–æ –≤–∫–∞–∑—ñ–≤–Ω–∏–∫). `shared_ptr` –º–∞—î –∞—Ç–æ–º–∞—Ä–Ω–∏–π –ª—ñ—á–∏–ª—å–Ω–∏–∫ –ø–æ—Å–∏–ª–∞–Ω—å —ñ –¥–æ–¥–∞—Ç–∫–æ–≤–∏–π –±–ª–æ–∫ –ø–∞–º'—è—Ç—ñ (control block), —â–æ –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ.
3. `[](int a, int b) { return a + b; };`
4. –õ—ñ—á–∏–ª—å–Ω–∏–∫ –ø–æ—Å–∏–ª–∞–Ω—å –Ω—ñ–∫–æ–ª–∏ –Ω–µ —Å—Ç–∞–Ω–µ –Ω—É–ª–µ–º, –±–æ –æ–±'—î–∫—Ç–∏ —Ç—Ä–∏–º–∞—é—Ç—å –æ–¥–∏–Ω –æ–¥–Ω–æ–≥–æ. –ü–∞–º'—è—Ç—å –Ω—ñ–∫–æ–ª–∏ –Ω–µ –∑–≤—ñ–ª—å–Ω–∏—Ç—å—Å—è.

</details>
