# Лекція [X]: Performance Engineering. Чому твій код повільний?

← [Index](index.md)

---

## 1. Вступ: Швидкість як фіча

* **Теза:** Користувач не бачить ваш класний код, він бачить спінер завантаження. Якщо це довго — він йде.
* **Міф:** "Комп'ютери швидкі, можна писати як завгодно".
* **Реальність:** Закон Мура сповільнився. Single-thread performance майже не росте. Ми виграємо тільки за рахунок архітектури та паралелізму.
* **Цитата:** *"Premature optimization is the root of all evil"* (Knuth).
* *Уточнення:* Це не означає "пиши гівнокод". Це означає "не оптимізуй те, що ти не виміряв".



## 2. Ієрархія пам'яті (The Lie of RAM)

* Студенти думають: `CPU <-> RAM`.
* Інженери знають: `CPU <-> Regs <-> L1 <-> L2 <-> L3 <-> RAM`.
* **Аналогія відстаней (Latency Numbers):**
* L1 cache (CPU): Взяти книгу зі столу (1 сек).
* L2 cache: Взяти книгу з полиці (4 сек).
* RAM (Main Memory): Сходити в бібліотеку на сусідній вулиці (2 хвилини).
* Disk (SSD): Полетіти на Марс за книгою.


* **Cache Miss:** Найгірше, що може статися з процесором — він чекає дані з RAM. У цей час він не працює.
* **Висновок:** `std::vector` (суцільна пам'ять) майже завжди швидший за `std::list` (розкидані вузли), бо він дружить з кешем.

## 3. Інструментарій: Не гадай — вимірюй

### Рівень 0: `std::chrono`

Базовий бенчмаркінг всередині коду.

```cpp
auto start = std::chrono::high_resolution_clock::now();
// ... code ...
auto end = std::chrono::high_resolution_clock::now();
// don't use "seconds", use "microseconds" or "nanoseconds"

```

### Рівень 1: Linux `perf` (The Holy Grail)

Ми не можемо бачити очима, де програма тупить. Нам потрібен рентген.
**Perf** — це інструмент Linux Kernel, який рахує апаратні події процесора.

#### Сценарій 1: Загальний чек-ап (`perf stat`)

```bash
perf stat -d ./my_program

```

**На що дивитись у виводі:**

1. **Task-clock:** Наскільки ми завантажили CPU.
2. **Instructions per cycle (IPC):** Якщо < 1.0, значить процесор простоює (чекає пам'ять).
3. **L1-dcache-load-misses:** Скільки разів ми промазали повз кеш. Чим більше — тим гірше.

#### Сценарій 2: Хто винен? (`perf record`)

```bash
# 1. Записуємо профіль (частота 99 Гц)
perf record -g -- ./my_program

# 2. Дивимось звіт
perf report

```

* Показує % часу, витраченого в кожній функції.
* Якщо 90% часу в функції `std::string::operator+`, то не треба оптимізувати математику, треба прибрати конкатенацію рядків.

*(Опціонально згадати FlameGraph як візуалізацію цього звіту).*

## 4. Головні вбивці продуктивності (Anti-patterns)

### А. Зайві копіювання (Copy Hell)

* Передача `std::vector` або `std::string` у функцію *за значенням*.
* **Fix:** `const std::string&` або `std::string_view` (C++17).

### Б. Виділення пам'яті в циклі (Allocation Hell)

* `new`/`malloc` — це повільно (системний виклик, пошук вільного блоку).
* **Bad:**
```cpp
for(int i=0; i<1000; ++i) {
    std::vector<int> v; // Malloc every iteration
    // ...
}

```


* **Good:** Винести вектор за цикл, робити `v.clear()`. Або `v.reserve()`.

### В. IO (Ввід-вивід)

* `std::endl` робить `flush` (скидає буфер на диск). Це вбиває перформанс.
* **Fix:** Використовувати `\n`.

## 5. Live Demo (Script)

*У реальному часі беремо задачу з "Практикуму 9" (обробка логів).*

1. **Версія V0 (Naive):** Читаємо по слову в `string`, передаємо копії.
* *Run:* 15 секунд.
* *Perf:* Показуємо купу `malloc` та `memcpy`.


2. **Версія V1 (Refactored):** `const &`, `reserve()`, `\n` замість `endl`.
* *Run:* 0.8 секунд.
* *Висновок:* Прискорення в 20 разів без асемблера, просто за рахунок інженерної гігієни.

---

### Примітки для викладача (Vitaliy):

* **Демонстрація:** Треба мати підготовлену віртуалку або WSL2, де працює `perf`. На Mac (M-series) `perf` не працює нативно (там Instruments), тому краще показувати в Docker/Linux середовищі, або чесно сказати про обмеження.
* **Візуалізація:** Обов'язково показати скріншот терміналу з `perf report` (ці червоні відсотки напроти функцій). Це справляє враження "Матриці".
* **Homework:** Змусити їх запустити `perf stat` на їхньому домашньому завданні і просто скинути скріншот виводу. Нехай звикнуть бачити метрики "Instructions" та "Branch misses".