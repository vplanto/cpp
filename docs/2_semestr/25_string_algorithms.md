# –õ–µ–∫—Ü—ñ—è 25: String Algorithms ‚Äî Pattern Matching

[‚Üê –õ–µ–∫—Ü—ñ—è 24](24_performance_deep_dive.md) | [Index](index.md) | [–î–∞–ª—ñ: –õ–µ–∫—Ü—ñ—è 26 ‚Üí](26_tree_structures.md)

## –ú–µ—Ç–∞

–ù–∞–≤—á–∏—Ç–∏—Å—è –∑–Ω–∞—Ö–æ–¥–∏—Ç–∏ –ø–∞—Ç–µ—Ä–Ω–∏ (–ø—ñ–¥—Ä—è–¥–∫–∏) —É —Ç–µ–∫—Å—Ç–∞—Ö –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ. –ó—Ä–æ–∑—É–º—ñ—Ç–∏ —Ç—Ä–∏ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ñ –∞–ª–≥–æ—Ä–∏—Ç–º–∏: Naive, Rabin-Karp, —Ç–∞ Knuth-Morris-Pratt (KMP). –í–º—ñ—Ç–∏ –æ–±–∏—Ä–∞—Ç–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—ó –∑–∞–¥–∞—á—ñ.

> **üìö –ú–∞—Ç–µ—Ä—ñ–∞–ª –ª–µ–∫—Ü—ñ—ó –±–∞–∑—É—î—Ç—å—Å—è –Ω–∞:**  
> String Algorithms using Lists.pdf

![String Algorithms ‚Äî –∑–∞–≥–∞–ª—å–Ω–∞ –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è](attachments/strings-000.jpg)

*–†–∏—Å. 1: –ê–ª–≥–æ—Ä–∏—Ç–º–∏ –ø–æ—à—É–∫—É —Ä—è–¥–∫—ñ–≤ ‚Äî –≤—ñ–¥ Naive –¥–æ KMP*

## –ï–∫—Å–ø—Ä–µ—Å-–æ–ø–∏—Ç—É–≤–∞–Ω–Ω—è

1. –°–∫—ñ–ª—å–∫–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω—å —Å–∏–º–≤–æ–ª—ñ–≤ –ø–æ—Ç—Ä—ñ–±–Ω–æ —É –Ω–∞–π–≥—ñ—Ä—à–æ–º—É –≤–∏–ø–∞–¥–∫—É, —â–æ–± –∑–Ω–∞–π—Ç–∏ –ø–∞—Ç–µ—Ä–Ω –¥–æ–≤–∂–∏–Ω–æ—é m —É —Ç–µ–∫—Å—Ç—ñ –¥–æ–≤–∂–∏–Ω–æ—é n –Ω–∞—ó–≤–Ω–∏–º –º–µ—Ç–æ–¥–æ–º?
2. –ß–∏ –º–æ–∂–Ω–∞ –∑–Ω–∞–π—Ç–∏ –≤—Å—ñ –≤—Ö–æ–¥–∂–µ–Ω–Ω—è –ø–∞—Ç–µ—Ä–Ω–∞ –∑–∞ –æ–¥–∏–Ω –ø—Ä–æ—Ö—ñ–¥ –ø–æ —Ç–µ–∫—Å—Ç—É?
3. –©–æ —à–≤–∏–¥—à–µ –¥–ª—è CPU: –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –¥–≤–æ—Ö —á–∏—Å–µ–ª —á–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –¥–≤–æ—Ö —Ä—è–¥–∫—ñ–≤?

<details markdown="1">
<summary>–Ü–Ω–∂–µ–Ω–µ—Ä–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å</summary>

1. **O(n * m) –ø–æ—Ä—ñ–≤–Ω—è–Ω—å.** –î–ª—è –∫–æ–∂–Ω–æ—ó –∑ n –ø–æ–∑–∏—Ü—ñ–π —É —Ç–µ–∫—Å—Ç—ñ –º–∏ –º–æ–∂–µ–º–æ –ø–æ—Ä—ñ–≤–Ω—é–≤–∞—Ç–∏ –¥–æ m —Å–∏–º–≤–æ–ª—ñ–≤ –ø–∞—Ç–µ—Ä–Ω–∞. –î–ª—è n=1,000,000 —ñ m=1000 —Ü–µ –º—ñ–ª—å—è—Ä–¥ –ø–æ—Ä—ñ–≤–Ω—è–Ω—å!
2. **–¢–∞–∫!** KMP –∞–ª–≥–æ—Ä–∏—Ç–º —Ä–æ–±–∏—Ç—å —Ü–µ –∑–∞ O(n + m) ‚Äî –æ–¥–∏–Ω –ø—Ä–æ—Ö—ñ–¥ –ø–æ —Ç–µ–∫—Å—Ç—É –ø–ª—é—Å –ø—Ä–µ–ø—Ä–æ—Ü–µ—Å–∏–Ω–≥ –ø–∞—Ç–µ—Ä–Ω–∞.
3. **–ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —á–∏—Å–µ–ª.** –û–¥–Ω–∞ CPU —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—è –ø—Ä–æ—Ç–∏ —Ü–∏–∫–ª—É –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –∫–æ–∂–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞. –û—Å—å —á–æ–º—É Rabin-Karp –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î —Ö–µ—à—ñ (—á–∏—Å–ª–∞) –∑–∞–º—ñ—Å—Ç—å –ø—Ä—è–º–æ–≥–æ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —Ä—è–¥–∫—ñ–≤.

</details>

---

## –ß–∞—Å—Ç–∏–Ω–∞ 1: –ü—Ä–æ–±–ª–µ–º–∞ –ø–æ—à—É–∫—É –ø–∞—Ç–µ—Ä–Ω–∞

### –§–æ—Ä–º—É–ª—é–≤–∞–Ω–Ω—è

**–î–∞–Ω–æ:** 
- –¢–µ–∫—Å—Ç `T` –¥–æ–≤–∂–∏–Ω–æ—é `n`
- –ü–∞—Ç–µ—Ä–Ω `P` –¥–æ–≤–∂–∏–Ω–æ—é `m` (–¥–µ m ‚â§ n)

**–ó–Ω–∞–π—Ç–∏:** –í—Å—ñ –ø–æ–∑–∏—Ü—ñ—ó `i`, –¥–µ `T[i...i+m-1] == P[0...m-1]`

### –ü—Ä–∏–∫–ª–∞–¥–∏ –∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Å–≤—ñ—Ç—É

1. **Ctrl+F** —É –±—Ä–∞—É–∑–µ—Ä—ñ ‚Äî –∑–Ω–∞–π—Ç–∏ –≤—Å—ñ –≤—Ö–æ–¥–∂–µ–Ω–Ω—è —Å–ª–æ–≤–∞ –Ω–∞ —Å—Ç–æ—Ä—ñ–Ω—Ü—ñ
2. **DNA —Å–µ–∫–≤–µ–Ω—É–≤–∞–Ω–Ω—è** ‚Äî –∑–Ω–∞–π—Ç–∏ –≥–µ–Ω–µ—Ç–∏—á–Ω–∏–π –º–∞—Ä–∫–µ—Ä —É –≥–µ–Ω–æ–º—ñ
3. **Plagiarism detection** ‚Äî –∑–Ω–∞–π—Ç–∏ —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω—ñ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∏ —Ç–µ–∫—Å—Ç—É
4. **Log analysis** ‚Äî –∑–Ω–∞–π—Ç–∏ –≤—Å—ñ –ø–æ–º–∏–ª–∫–∏ —É —Ñ–∞–π–ª—ñ –ª–æ–≥—ñ–≤
5. **Antivirus** ‚Äî –∑–Ω–∞–π—Ç–∏ —Å–∏–≥–Ω–∞—Ç—É—Ä—É –≤—ñ—Ä—É—Å—É —É —Ñ–∞–π–ª—ñ

**–ß–æ–º—É –≤–∞–∂–ª–∏–≤–æ:** –¢–µ–∫—Å—Ç –º–æ–∂–µ –±—É—Ç–∏ –≥—ñ–≥–∞–Ω—Ç—Å—å–∫–∏–º (–≥–µ–Ω–æ–º –ª—é–¥–∏–Ω–∏ ‚Äî 3 –º–ª—Ä–¥ —Å–∏–º–≤–æ–ª—ñ–≤), —Ç–æ–º—É O(n¬≤) –Ω–µ–ø—Ä–∏–π–Ω—è—Ç–Ω–æ.

---

## –ß–∞—Å—Ç–∏–Ω–∞ 2: Naive Algorithm ‚Äî –≥—Ä—É–±–æ—é —Å–∏–ª–æ—é

### –Ü–¥–µ—è

–ü–µ—Ä–µ–≤—ñ—Ä—è–π –∫–æ–∂–Ω—É –ø–æ–∑–∏—Ü—ñ—é —Ç–µ–∫—Å—Ç—É: —á–∏ –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è —Ç–∞–º –ø–∞—Ç–µ—Ä–Ω?

```
Text:    A B C A B D A B C
Pattern: A B C

Position 0: A B C == A B C ‚úì (match!)
Position 1: B C A ‚â† A B C
Position 2: C A B ‚â† A B C
...
Position 6: A B C == A B C ‚úì (match!)
```

### –ö–æ–¥

```cpp
#include <vector>
#include <string>

std::vector<int> naive_search(const std::string& text, const std::string& pattern) {
    std::vector<int> matches;
    int n = text.length();
    int m = pattern.length();
    
    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∫–æ–∂–Ω—É –ø–æ–∑–∏—Ü—ñ—é
    for (int i = 0; i <= n - m; i++) {
        // –ü–æ—Ä—ñ–≤–Ω—é—î–º–æ –ø–∞—Ç–µ—Ä–Ω –∑ –ø—ñ–¥—Ä—è–¥–∫–æ–º —Ç–µ–∫—Å—Ç—É
        bool found = true;
        for (int j = 0; j < m; j++) {
            if (text[i + j] != pattern[j]) {
                found = false;
                break;
            }
        }
        
        if (found) {
            matches.push_back(i);
        }
    }
    
    return matches;
}
```

### –°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å

- **–ù–∞–π–∫—Ä–∞—â–∏–π –≤–∏–ø–∞–¥–æ–∫:** O(n) ‚Äî –ø–µ—Ä—à–∏–π —Å–∏–º–≤–æ–ª –∑–∞–≤–∂–¥–∏ –Ω–µ –∑–±—ñ–≥–∞—î—Ç—å—Å—è
- **–ù–∞–π–≥—ñ—Ä—à–∏–π –≤–∏–ø–∞–¥–æ–∫:** O(n * m) ‚Äî –ø–∞—Ç–µ—Ä–Ω –º–∞–π–∂–µ –∑–±—ñ–≥–∞—î—Ç—å—Å—è –∫–æ–∂–Ω–æ–≥–æ —Ä–∞–∑—É

**–ü—Ä–∏–∫–ª–∞–¥ –Ω–∞–π–≥—ñ—Ä—à–æ–≥–æ –≤–∏–ø–∞–¥–∫—É:**
```
Text:    AAAAAAAAAB
Pattern: AAAAB
```
–î–ª—è –∫–æ–∂–Ω–æ—ó –ø–æ–∑–∏—Ü—ñ—ó –ø–æ—Ä—ñ–≤–Ω—è—î–º–æ 4 —Å–∏–º–≤–æ–ª–∏ –ø–µ—Ä–µ–¥ –Ω–µ–≤–¥–∞—á–µ—é.

---

## –ß–∞—Å—Ç–∏–Ω–∞ 3: Rabin-Karp ‚Äî Rolling Hash

### –Ü–¥–µ—è

–ó–∞–º—ñ—Å—Ç—å –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —Ä—è–¥–∫—ñ–≤, –ø–æ—Ä—ñ–≤–Ω—é—î–º–æ —ó—Ö **—Ö–µ—à—ñ** (—á–∏—Å–ª–∞). –Ø–∫—â–æ —Ö–µ—à—ñ –∑–±—ñ–≥–∞—é—Ç—å—Å—è ‚Äî –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ä—è–¥–æ–∫ –¥–ª—è —É–ø–µ–≤–Ω–µ–Ω–æ—Å—Ç—ñ (collision check).

**–ö–ª—é—á–æ–≤–∞ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è:** Rolling Hash ‚Äî –æ–±—á–∏—Å–ª—é—î–º–æ —Ö–µ—à –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –≤—ñ–∫–Ω–∞ –∑–∞ O(1), –Ω–µ –ø–µ—Ä–µ—Ä–∞—Ö–æ–≤—É—é—á–∏ –≤—Å–µ –∑ –Ω—É–ª—è.

### Hash Function

–Ü–Ω—Ç–µ—Ä–ø—Ä–µ—Ç—É—î–º–æ —Ä—è–¥–æ–∫ —è–∫ —á–∏—Å–ª–æ —É p-—á–Ω—ñ–π —Å–∏—Å—Ç–µ–º—ñ —á–∏—Å–ª–µ–Ω–Ω—è:

```
hash("ABC") = A*p^0 + B*p^1 + C*p^2  (mod M)
```

–¥–µ `p` ‚Äî –ø—Ä–æ—Å—Ç–µ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 31), `M` ‚Äî –≤–µ–ª–∏–∫–∏–π –º–æ–¥—É–ª—å (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 10^9 + 9).

### Rolling Hash –º–µ—Ö–∞–Ω—ñ–∑–º

```
Text: [A B C] D E
       ‚Üì
Text:  A [B C D] E

–°—Ç–∞—Ä–∏–π —Ö–µ—à: A*p^0 + B*p^1 + C*p^2
–ù–æ–≤–∏–π —Ö–µ—à: B*p^0 + C*p^1 + D*p^2

–§–æ—Ä–º—É–ª–∞: new_hash = (old_hash - A*p^0) / p + D*p^(m-1)
```

### –ö–æ–¥

```cpp
#include <vector>
#include <string>

const long long P = 31;
const long long M = 1e9 + 9;

long long compute_hash(const std::string& s) {
    long long hash_value = 0;
    long long p_pow = 1;
    
    for (char c : s) {
        hash_value = (hash_value + (c - 'a' + 1) * p_pow) % M;
        p_pow = (p_pow * P) % M;
    }
    
    return hash_value;
}

std::vector<int> rabin_karp(const std::string& text, const std::string& pattern) {
    std::vector<int> matches;
    int n = text.length();
    int m = pattern.length();
    
    if (m > n) return matches;
    
    // –û–±—á–∏—Å–ª—é—î–º–æ —Ö–µ—à –ø–∞—Ç–µ—Ä–Ω–∞
    long long pattern_hash = compute_hash(pattern);
    
    // –û–±—á–∏—Å–ª—é—î–º–æ —Ö–µ—à –ø–µ—Ä—à–æ–≥–æ –≤—ñ–∫–Ω–∞ —Ç–µ–∫—Å—Ç—É
    long long text_hash = compute_hash(text.substr(0, m));
    
    // –û–±—á–∏—Å–ª—é—î–º–æ p^m –¥–ª—è rolling hash
    long long p_pow_m = 1;
    for (int i = 0; i < m; i++) {
        p_pow_m = (p_pow_m * P) % M;
    }
    
    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤—Å—ñ –≤—ñ–∫–Ω–∞
    for (int i = 0; i <= n - m; i++) {
        if (text_hash == pattern_hash) {
            // –•–µ—à—ñ –∑–±—ñ–≥–ª–∏—Å—è ‚Äî –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ä—è–¥–æ–∫ (–Ω–∞ –≤–∏–ø–∞–¥–æ–∫ –∫–æ–ª—ñ–∑—ñ—ó)
            if (text.substr(i, m) == pattern) {
                matches.push_back(i);
            }
        }
        
        // Rolling hash –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –≤—ñ–∫–Ω–∞
        if (i < n - m) {
            text_hash = (text_hash - (text[i] - 'a' + 1)) % M;
            text_hash = (text_hash / P) % M;
            text_hash = (text_hash + (text[i + m] - 'a' + 1) * p_pow_m) % M;
            
            // –ö–æ—Ä–∏–≥—É–≤–∞–Ω–Ω—è –¥–ª—è –≤—ñ–¥'—î–º–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω—å
            if (text_hash < 0) text_hash += M;
        }
    }
    
    return matches;
}
```

### –°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å

- **Preprocessing:** O(m) ‚Äî –æ–±—á–∏—Å–ª–µ–Ω–Ω—è —Ö–µ—à—É –ø–∞—Ç–µ—Ä–Ω–∞
- **Searching:** O(n + m) –≤ —Å–µ—Ä–µ–¥–Ω—å–æ–º—É, O(n * m) —É –Ω–∞–π–≥—ñ—Ä—à–æ–º—É (–±–∞–≥–∞—Ç–æ –∫–æ–ª—ñ–∑—ñ–π)
- **Space:** O(1)

---

## –ß–∞—Å—Ç–∏–Ω–∞ 4: Knuth-Morris-Pratt (KMP) ‚Äî —Ä–æ–∑—É–º–Ω–∏–π –ø–æ—à—É–∫

### –ü—Ä–æ–±–ª–µ–º–∞ Naive –ø—ñ–¥—Ö–æ–¥—É

```
Text:    A B C A B D
Pattern: A B C A B E

Position 0:
A B C A B D
A B C A B E
        ‚úó (mismatch at position 5)

Naive: –ø–æ—á–∏–Ω–∞—î–º–æ –∑ –ø–æ–∑–∏—Ü—ñ—ó 1
KMP:   "–°—Ç–æ–ø! –ú–∏ –≤–∂–µ –∑–Ω–∞—î–º–æ, —â–æ —î AB –ø—ñ—Å–ª—è –Ω–µ–≤–¥–∞—á—ñ, –ø–æ—á–∏–Ω–∞—î–º–æ –∑ –ø–æ–∑–∏—Ü—ñ—ó 4"
```

**–Ü–¥–µ—è KMP:** –ù–µ –ø–æ—á–∏–Ω–∞—Ç–∏ –∑ –Ω—É–ª—è –ø—ñ—Å–ª—è –Ω–µ–≤–¥–∞—á—ñ. –í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –∑ –≤–∂–µ –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω–∏—Ö —Å–∏–º–≤–æ–ª—ñ–≤.

### Prefix Function (Failure Function)

–î–ª—è –ø–∞—Ç–µ—Ä–Ω–∞ –æ–±—á–∏—Å–ª—é—î–º–æ `pi[i]` ‚Äî –¥–æ–≤–∂–∏–Ω–∞ –Ω–∞–π–¥–æ–≤—à–æ–≥–æ proper prefix, —è–∫–∏–π —Ç–∞–∫–æ–∂ —î suffix.

**–ü—Ä–∏–∫–ª–∞–¥ –¥–ª—è –ø–∞—Ç–µ—Ä–Ω–∞ "ABABC":**

| i | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
| pattern[i] | A | B | A | B | C |
| pi[i] | 0 | 0 | 1 | 2 | 0 |

**–ü–æ—è—Å–Ω–µ–Ω–Ω—è:**
- `pi[0] = 0` (–ø–æ—Ä–æ–∂–Ω—ñ–π prefix)
- `pi[1] = 0` ("AB" –Ω–µ–º–∞—î proper prefix == suffix)
- `pi[2] = 1` ("ABA": prefix "A" == suffix "A")
- `pi[3] = 2` ("ABAB": prefix "AB" == suffix "AB")
- `pi[4] = 0` ("ABABC": –Ω–µ–º–∞—î –∑–±—ñ–≥—ñ–≤)

### –ü–æ–±—É–¥–æ–≤–∞ Prefix Function

```cpp
#include <vector>
#include <string>

std::vector<int> compute_prefix_function(const std::string& pattern) {
    int m = pattern.length();
    std::vector<int> pi(m, 0);
    
    for (int i = 1; i < m; i++) {
        int j = pi[i - 1];
        
        // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –Ω–∞–π–¥–æ–≤—à–∏–π prefix
        while (j > 0 && pattern[i] != pattern[j]) {
            j = pi[j - 1];
        }
        
        if (pattern[i] == pattern[j]) {
            j++;
        }
        
        pi[i] = j;
    }
    
    return pi;
}
```

### KMP Search

```cpp
std::vector<int> kmp_search(const std::string& text, const std::string& pattern) {
    std::vector<int> matches;
    int n = text.length();
    int m = pattern.length();
    
    // –û–±—á–∏—Å–ª—é—î–º–æ prefix function
    std::vector<int> pi = compute_prefix_function(pattern);
    
    int j = 0;  // –ü–æ—Ç–æ—á–Ω–∞ –ø–æ–∑–∏—Ü—ñ—è —É –ø–∞—Ç–µ—Ä–Ω—ñ
    
    for (int i = 0; i < n; i++) {
        // –Ø–∫—â–æ –Ω–µ –∑–±—ñ–≥–∞—î—Ç—å—Å—è, –∑—Å—É–≤–∞—î–º–æ—Å—å –Ω–∞–∑–∞–¥ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ pi
        while (j > 0 && text[i] != pattern[j]) {
            j = pi[j - 1];
        }
        
        if (text[i] == pattern[j]) {
            j++;
        }
        
        // –ó–Ω–∞–π—à–ª–∏ –ø–æ–≤–Ω–µ –≤—Ö–æ–¥–∂–µ–Ω–Ω—è
        if (j == m) {
            matches.push_back(i - m + 1);
            j = pi[j - 1];  // –ü—Ä–æ–¥–æ–≤–∂—É—î–º–æ –ø–æ—à—É–∫
        }
    }
    
    return matches;
}
```

### –°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å

- **Preprocessing:** O(m) ‚Äî –ø–æ–±—É–¥–æ–≤–∞ prefix function
- **Searching:** O(n) ‚Äî **–æ–¥–∏–Ω –ø—Ä–æ—Ö—ñ–¥ –ø–æ —Ç–µ–∫—Å—Ç—É!**
- **Total:** O(n + m) ‚Äî **–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è pattern matching**
- **Space:** O(m) –¥–ª—è prefix table

**–ß–æ–º—É O(n)?** –ó–º—ñ–Ω–Ω–∞ `j` –Ω—ñ–∫–æ–ª–∏ –Ω–µ –∑–º–µ–Ω—à—É—î—Ç—å—Å—è –±—ñ–ª—å—à–µ, –Ω—ñ–∂ –∑–±—ñ–ª—å—à—É–≤–∞–ª–∞—Å—è, —Ç–æ–º—É –∑–∞–≥–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü—ñ–π –ª—ñ–Ω—ñ–π–Ω–∞.

---

## –ß–∞—Å—Ç–∏–Ω–∞ 5: –ü–æ—Ä—ñ–≤–Ω—è–ª—å–Ω–∞ —Ç–∞–±–ª–∏—Ü—è

| –ê–ª–≥–æ—Ä–∏—Ç–º | Preprocessing | Search | Total | Space | –ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ |
|----------|---------------|--------|-------|-------|---------------------|
| **Naive** | O(1) | O(n*m) | O(n*m) | O(1) | –î—É–∂–µ –∫–æ—Ä–æ—Ç–∫—ñ –ø–∞—Ç–µ—Ä–Ω–∏ (m < 5) |
| **Rabin-Karp** | O(m) | O(n+m) avg | O(n+m) avg | O(1) | –ë–∞–≥–∞—Ç–æ –ø–∞—Ç–µ—Ä–Ω—ñ–≤ –æ–¥–Ω–æ—á–∞—Å–Ω–æ |
| **KMP** | O(m) | O(n) | O(n+m) | O(m) | **–ì–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∏–π –ª—ñ–Ω—ñ–π–Ω–∏–π —á–∞—Å** |

### –ö–æ–ª–∏ —â–æ –æ–±–∏—Ä–∞—Ç–∏?

1. **KMP** ‚Äî –∫–æ–ª–∏ –ø–æ—Ç—Ä—ñ–±–Ω–∞ **–≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∞** –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å O(n+m)
2. **Rabin-Karp** ‚Äî –∫–æ–ª–∏ —à—É–∫–∞—î–º–æ **–±–∞–≥–∞—Ç–æ —Ä—ñ–∑–Ω–∏—Ö –ø–∞—Ç–µ—Ä–Ω—ñ–≤** —É —Ç–æ–º—É –∂ —Ç–µ–∫—Å—Ç—ñ
3. **Naive** ‚Äî –∫–æ–ª–∏ –ø–∞—Ç–µ—Ä–Ω **–¥—É–∂–µ –∫–æ—Ä–æ—Ç–∫–∏–π** (2-3 —Å–∏–º–≤–æ–ª–∏) —ñ –∫–æ–¥ –º–∞—î –±—É—Ç–∏ –ø—Ä–æ—Å—Ç–∏–º

**–£ std::string::find()** –∑–∞–∑–≤–∏—á–∞–π –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π Naive –∞–±–æ Boyer-Moore.

---

## –ü—Ä–∞–∫—Ç–∏—á–Ω–µ –∑–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è

**–î–∏–≤.:** [–ü—Ä–∞–∫—Ç–∏–∫—É–º 18: Pattern Matching](p18_pattern_matching.md) ‚Äî —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è –≤—Å—ñ—Ö —Ç—Ä—å–æ—Ö –∞–ª–≥–æ—Ä–∏—Ç–º—ñ–≤ —ñ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ.

---

## –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω—ñ –ø–∏—Ç–∞–Ω–Ω—è

1. –ß–æ–º—É Rabin-Karp –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î rolling hash –∑–∞–º—ñ—Å—Ç—å –ø–µ—Ä–µ—Ä–∞—Ö—É–Ω–∫—É —Ö–µ—à—É –∑ –Ω—É–ª—è –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –≤—ñ–∫–Ω–∞?

<details markdown="1">
<summary>–í—ñ–¥–ø–æ–≤—ñ–¥—å</summary>

Rolling hash –¥–æ–∑–≤–æ–ª—è—î –æ–Ω–æ–≤–∏—Ç–∏ —Ö–µ—à –∑–∞ O(1) –∑–∞–º—ñ—Å—Ç—å O(m):
- –í–∏–¥–∞–ª—è—î–º–æ –≤–Ω–µ—Å–æ–∫ –ø–µ—Ä—à–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ —Å—Ç–∞—Ä–æ–≥–æ –≤—ñ–∫–Ω–∞
- –ó—Å—É–≤–∞—î–º–æ –≤—Å—ñ –ø–æ–∑–∏—Ü—ñ—ó –Ω–∞ –æ–¥–∏–Ω —Å—Ç–µ–ø—ñ–Ω—å –≤–Ω–∏–∑ (–¥—ñ–ª–∏–º–æ –Ω–∞ p)
- –î–æ–¥–∞—î–º–æ –≤–Ω–µ—Å–æ–∫ –Ω–æ–≤–æ–≥–æ —Å–∏–º–≤–æ–ª–∞

–ë–µ–∑ rolling hash: O(m) –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –≤—ñ–∫–Ω–∞ ‚Üí O(n*m) –∑–∞–≥–∞–ª–æ–º.
–ó rolling hash: O(1) –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –≤—ñ–∫–Ω–∞ ‚Üí O(n) –∑–∞–≥–∞–ª–æ–º.

</details>

2. –£ —á–æ–º—É —Ä—ñ–∑–Ω–∏—Ü—è –º—ñ–∂ "proper prefix" —Ç–∞ "prefix"?

<details markdown="1">
<summary>–í—ñ–¥–ø–æ–≤—ñ–¥—å</summary>

- **Prefix**: –ë—É–¥—å-—è–∫–∏–π –ø–æ—á–∞—Ç–æ–∫ —Ä—è–¥–∫–∞, –≤–∫–ª—é—á–∞—é—á–∏ —Å–∞–º —Ä—è–¥–æ–∫. –î–ª—è "ABC": "", "A", "AB", "ABC"
- **Proper prefix**: Prefix, —â–æ –Ω–µ –¥–æ—Ä—ñ–≤–Ω—é—î –≤—Å—å–æ–º—É —Ä—è–¥–∫—É. –î–ª—è "ABC": "", "A", "AB"

–£ KMP –º–∏ —à—É–∫–∞—î–º–æ proper prefix, –±–æ —è–∫—â–æ prefix == –≤–µ—Å—å —Ä—è–¥–æ–∫, —Ü–µ –Ω–µ –¥–æ–ø–æ–º–∞–≥–∞—î –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–∏ —Å–∏–º–≤–æ–ª–∏.

</details>

3. –ß–æ–º—É KMP –º–∞—î —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å O(n), —Ö–æ—á–∞ —Ç–∞–º —î —Ü–∏–∫–ª while –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ —Ü–∏–∫–ª—É for?

<details markdown="1">
<summary>–í—ñ–¥–ø–æ–≤—ñ–¥—å</summary>

**Amortized analysis**: –ó–º—ñ–Ω–Ω–∞ `j` –º–æ–∂–µ —Ç—ñ–ª—å–∫–∏ –∑–±—ñ–ª—å—à—É–≤–∞—Ç–∏—Å—å –ø—Ä–∏ `text[i] == pattern[j]` (–º–∞–∫—Å–∏–º—É–º n —Ä–∞–∑—ñ–≤) —ñ –∑–º–µ–Ω—à—É–≤–∞—Ç–∏—Å—å —É while (–º–∞–∫—Å–∏–º—É–º —Å—Ç—ñ–ª—å–∫–∏ –∂ —Ä–∞–∑—ñ–≤, —Å–∫—ñ–ª—å–∫–∏ –∑–±—ñ–ª—å—à—É–≤–∞–ª–∞—Å—å).

–ó–∞–≥–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∑–±—ñ–ª—å—à–µ–Ω—å + –∑–º–µ–Ω—à–µ–Ω—å = O(n). –û—Ç–∂–µ, –∑–∞–≥–∞–ª—å–Ω–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å O(n), –∞ –Ω–µ O(n¬≤).

</details>

4. –ö–æ–ª–∏ Rabin-Karp –º–æ–∂–µ –¥–µ–≥—Ä–∞–¥—É–≤–∞—Ç–∏ –¥–æ O(n*m)?

<details markdown="1">
<summary>–í—ñ–¥–ø–æ–≤—ñ–¥—å</summary>

–ö–æ–ª–∏ –±–∞–≥–∞—Ç–æ **hash collisions** (—Ä—ñ–∑–Ω—ñ —Ä—è–¥–∫–∏ –∑ –æ–¥–Ω–∞–∫–æ–≤–∏–º —Ö–µ—à–µ–º). –¢–æ–¥—ñ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –≤—ñ–∫–Ω–∞ –¥–æ–≤–µ–¥–µ—Ç—å—Å—è —Ä–æ–±–∏—Ç–∏ –ø–æ–≤–Ω–µ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —Ä—è–¥–∫—ñ–≤ O(m).

–¶–µ –º–æ–∂–µ —Å—Ç–∞—Ç–∏—Å—è —è–∫—â–æ:
- –ü–æ–≥–∞–Ω–æ –æ–±—Ä–∞–Ω–∏–π p –∞–±–æ M
- –ó–ª–æ–≤–º–∏—Å–Ω–∏–∫ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–æ —Å—Ç–≤–æ—Ä–∏–≤ —Ç–µ–∫—Å—Ç –∑ –∫–æ–ª—ñ–∑—ñ—è–º–∏

–†—ñ—à–µ–Ω–Ω—è: –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –∫—ñ–ª—å–∫–∞ —Ö–µ—à-—Ñ—É–Ω–∫—Ü—ñ–π –∞–±–æ –ø–µ—Ä–µ–π—Ç–∏ –Ω–∞ KMP.

</details>
