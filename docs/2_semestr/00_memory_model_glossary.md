# Глосарій: Модель пам'яті та середовище виконання C++

> **Аудиторія:** Студенти прикладної математики
> **Мета:** Формальні визначення системних концепцій C++ без покладання на інженерний жаргон

← [Індекс курсу](index.md) | [English version](en/00_memory_model_glossary.md)

Цей документ визначає фундаментальну модель виконання C++ з використанням математичних позначень, знайомих студентам з формальним курсом дискретної математики та алгоритмів.

---

## 1. Пам'ять та тривалість зберігання

### Контекст проблеми

Документація C++ використовує розмовні терміни "стек" і "купа", які конфліктують із значеннями **абстрактних типів даних** (Stack = структура LIFO, Heap = черга з пріоритетами). Нам потрібна точна термінологія.

### Формальні визначення

Нехай $M$ позначає адресний простір пам'яті, доступний програмі:
$$M = \{m_0, m_1, m_2, \dots, m_{2^{64}-1}\}$$

Кожне $m_i$ представляє один адресований байт.

#### Класи тривалості зберігання

C++ визначає **чотири класи тривалості зберігання** (правила часу існування):

**1. Автоматична тривалість зберігання**

- **Розмовна назва:** "Стек" (оманлива — відносить до порядку виділення LIFO, а не до структури даних)
- **Час існування:** $[\text{вхід у область}, \text{вихід з області})$
- **Порядок виділення:** LIFO (Last In, First Out)
- **Звільнення:** Детерміноване, автоматичне при виході з області

**Формальна модель:**
```
Нехай область S має точку входу t₁ та точку виходу t₂.
Об'єкт x з автоматичним зберіганням має час існування:
  L(x) = [t₁, t₂)

Виділення:  push(stack_pointer, sizeof(x))
Звільнення: pop(stack_pointer, sizeof(x))  // Автоматично в t₂
```

**Приклад:**
```cpp
void foo() {
    int x = 42;  // Автоматичне зберігання
                  // Створюється при вході в область
}                // Знищується при виході (детерміновано)
```

---

**2. Динамічна тривалість зберігання**

- **Розмовна назва:** "Купа" (оманлива — НЕ є структурою heap, просто пул динамічного виділення)
- **Час існування:** $[\text{new-вираз}, \text{delete-вираз})$
- **Порядок виділення:** Недетермінований, керується ОС
- **Звільнення:** Ручне (відповідальність програміста)

**Формальна модель:**
```
Об'єкт x має динамічну тривалість зберігання, якщо:
  allocation_time(x)   = час виразу 'new'
  deallocation_time(x) = час виразу 'delete' (або ∞ при витоку)

Регіон пам'яті: Керується алокатором ОС (наприклад, malloc/free у C)
```

**Приклад:**
```cpp
int* p = new int(42);  // Динамічне зберігання, виділяється під час виконання
// ... довільний час існування ...
delete p;               // Потрібне ручне звільнення
```

**Витік пам'яті:**
$$\text{Витік} = \{x \mid x \text{ виділено, але } \nexists \text{ відповідний delete}\}$$

---

**3. Статична тривалість зберігання**

- **Час існування:** $[\text{запуск програми}, \text{завершення програми})$
- **Приклад:** Глобальні змінні, `static` локальні змінні

---

**4. Локальна для потоку тривалість зберігання**

- **Час існування:** $[\text{створення потоку}, \text{знищення потоку})$
- **Приклад:** Змінні `thread_local`

---

### Чому важлива різниця "Стек" vs "Купа"

**Характеристики продуктивності:**

| Властивість | Автоматичне (Стек) | Динамічне (Купа) |
|-------------|-------------------|------------------|
| **Вартість виділення** | $O(1)$ — інкремент вказівника | $O(\log n)$ до $O(n)$ — пошук вільного блоку |
| **Вартість звільнення** | $O(1)$ — автоматично | $O(\log n)$ — оновлення вільного списку |
| **Фрагментація** | Відсутня (суцільний LIFO) | Можлива (розкидані виділення) |
| **Контроль часу існування** | Обмежений областю (жорсткий) | Ручний (гнучкий, але схильний до помилок) |

---

## 2. Модель компіляції та компонування

### Контекст проблеми

Інженерна документація передбачає знання "об'єктних файлів" і "помилок компонувальника" без визначення фаз трансляції. Формалізуємо конвеєр компіляції.

### Конвеєр трансляції як композиція функцій

```
Source.cpp → [Препроцесор] → Translation_Unit.i →
[Компілятор] → Object_File.o → [Компонувальник] → Executable
```

**Формальні визначення:**

#### Одиниця трансляції (Translation Unit)

$$TU = \text{максимальна множина оголошень, видимих одному виклику компілятора}$$

Після препроцесора один файл `.cpp` стає однією одиницею трансляції.

**Приклад:**
```cpp
// foo.cpp
#include "header.h"  // Препроцесор замінює вмістом заголовочного файлу
int x = 42;

// Одиниця трансляції = {вміст header.h, int x = 42}
```

---

#### Символ (Symbol)

$$\text{Символ} = (\text{ім'я}, \text{сигнатура\_типу})$$

Символ — унікальний ідентифікатор функції або змінної.

**Приклад:**
```cpp
void foo(int x);        // Символ: (foo, int→void)
void foo(double x);     // Символ: (foo, double→void)  [інша сигнатура!]
```

---

#### Помилка компонувальника (Linker Error)

**Визначення:**
$$\text{Помилка компонувальника} \iff \exists s \in \text{Символи}_{\text{використані}} : s \notin \bigcup_{i} \text{Символи}_{\text{визначені}}(TU_i)$$

Простіше: символ використовується, але жодна одиниця трансляції не надає його визначення.

**Приклад:**
```cpp
// main.cpp
void external_func();  // Оголошення (символ використовується)
int main() {
    external_func();   // Використання
}

// Жоден інший .cpp не надає визначення external_func
// → Помилка компонувальника: undefined reference to external_func
```

---

### Чому шаблони мають бути у заголовках

**Проблема:**
Шаблони **не інстанціюються** до їх використання з конкретним типом.

**Модель:**
```
Нехай F = template<typename T> class Vector
Інстанціація: F(int) генерує реальний код для Vector<int>

Компілятор працює з кожною одиницею трансляції окремо:
  TU₁ бачить:   лише оголошення F
  TU₂ потребує: F(int) — але не може згенерувати код без визначення F!

Рішення: Визначення F має бути у заголовку (видиме для всіх TU)
```

---

## 3. Затримки апаратного забезпечення (Абстрактна імовірнісна модель)

### Контекст проблеми

Терміни "cache miss" і "branch prediction" передбачають знання мікроархітектури процесора. Абстрагуємо це як функції затримки.

### Функція затримки доступу

Визначимо $L: \text{МісцеПам'яті} \to \mathbb{R}^+$ як **очікуваний час** отримання даних.

**Ієрархія:**

| Місце | Затримка (цикли) | Аналогія в людському масштабі |
|-------|------------------|-------------------------------|
| Регістр CPU | $L(r) = 0$ | Миттєво (думка) |
| Кеш L1 | $L(\ell_1) \approx 4$ | 3 секунди |
| Кеш L2 | $L(\ell_2) \approx 12$ | 10 секунд |
| RAM | $L(\text{ram}) \approx 100$ | 5 хвилин |
| SSD | $L(\text{ssd}) \approx 100{,}000$ | 3 дні |

**Практичний вплив:**

Для циклу з доступом до масиву (суцільна пам'ять):
```cpp
for (int i = 0; i < N; i++) {
    sum += arr[i];  // Скоріше за все в кеші: L ≈ 4 цикли
}
```

Для зв'язного списку (розкидана пам'ять):
```cpp
for (Node* p = head; p != nullptr; p = p->next) {
    sum += p->data;  // Скоріше за все cache miss: L ≈ 100 циклів!
}
```

**Очікуваний час:**
- Масив: $4N$ циклів
- Зв'язний список: $100N$ циклів (у 25× повільніше при однаковій складності $O(n)$!)

---

### Передбачення гілок (Branch Prediction)

**Модель як імовірнісний класифікатор:**

Нехай $P(\text{правильне\_передбачення})$ = імовірність того, що CPU правильно вгадає наступну інструкцію.

- **Детермінований код:** $P \approx 0.95$ (95% точність)
- **Випадкові гілки:** $P \approx 0.5$ (підкидання монети)

**Віртуальні функції та збій передбачення:**

```cpp
for (Animal* a : animals) {
    a->speak();  // Тип під час виконання невідомий → випадкова гілка
}
```

Очікуваний штраф за виклик:
$$\text{Вартість} = P \cdot 0 + (1 - P) \cdot \text{штраф\_за\_хибне\_передбачення}$$

При $P = 0.5$, штраф $\approx$ 15 циклів:
$$\text{Вартість} = 0.5 \cdot 0 + 0.5 \cdot 15 = 7.5 \text{ циклів накладних витрат}$$

---

## 4. Примітиви паралелізму

### М'ютекс (Бінарний семафор)

**Простір станів:**
$$S = \{\text{розблокований}, \text{заблокований}\}$$

**Операції:**

$$\text{lock}: S \to S$$
$$\text{lock}(s) = \begin{cases}
\text{заблокований} & \text{якщо } s = \text{розблокований} \\
\text{ОЧІКУВАННЯ} & \text{якщо } s = \text{заблокований} \, (\text{чекати до розблокування})
\end{cases}$$

$$\text{unlock}: S \to S$$
$$\text{unlock}(s) = \begin{cases}
\text{розблокований} & \text{якщо } s = \text{заблокований} \\
\text{ПОМИЛКА} & \text{якщо } s = \text{розблокований}
\end{cases}$$

---

### Взаємоблокування (Deadlock)

**Формальне визначення:**

Нехай $T = \{T_1, T_2, \dots, T_n\}$ — потоки, а $M = \{M_1, M_2, \dots, M_m\}$ — м'ютекси.

**Взаємоблокування виникає**, якщо існує циклічне очікування:
$$T_1 \xrightarrow{\text{чекає}} M_1 \xrightarrow{\text{утримується}} T_2 \xrightarrow{\text{чекає}} M_2 \xrightarrow{\text{утримується}} T_1$$

**Приклад:**
```cpp
Потік 1:               Потік 2:
lock(M1);               lock(M2);
lock(M2);  ← БЛОК       lock(M1);  ← БЛОК
```

Обидва потоки чекають вічно: $\lim_{t \to \infty} \text{progress}(T_1) = \lim_{t \to \infty} \text{progress}(T_2) = 0$

---

## Довідкова таблиця

**При плутанині з жаргоном — зіставляйте з формальними визначеннями:**

| Інженерний термін | Формальний еквівалент |
|-------------------|-----------------------|
| "Стек" | Автоматична тривалість зберігання |
| "Купа" | Динамічна тривалість зберігання |
| "Помилка компонувальника" | Символ $s$ використовується, але $s \notin$ визначених символів |
| "Cache miss" | $L(\text{доступ}) = L(\text{ram}) \gg L(\ell_1)$ |
| "Deadlock" | Умова циклічного очікування |

Вся "магія" C++ зводиться до цих математичних моделей.
