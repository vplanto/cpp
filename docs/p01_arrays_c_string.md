# Практикум 1: Масиви та C-рядки — Визначаємо MVP матчу

## Частина 1: Експрес-опитування та розминка

Перш ніж писати код, давайте швидко перевіримо ключові поняття з лекції. Спробуйте відповісти на ці питання самостійно, а потім перевірте себе.

1.  Як у C++ оголосити масив для 5 чисел з плаваючою комою?
2.  Який індекс має **перший** елемент будь-якого масиву?
3.  Якщо масив має розмір 7, який індекс має його **останній** елемент?
4.  Як звернутися до другого елемента масиву `my_array`?
5.  Як присвоїти значення `15.5` четвертому елементу масиву `my_array`?
6.  Що станеться, якщо ми спробуємо звернутися до `my_array[7]` у масиві розміром 7?
7.  Чим по суті є C-рядок (C-string)?
8.  Який спеціальний символ завжди стоїть у кінці C-рядка?
9.  Як оголосити та ініціалізувати C-рядок зі словом "Test"?
10. У чому різниця між розміром масиву `char s[] = "Hi";` та довжиною рядка "Hi"?
11. Яка команда використовується для зчитування одного слова з клавіатури?
12. Яка команда використовується для зчитування цілого рядка з пробілами?

<details markdown="1">
<summary>Натисніть, щоб побачити відповіді на опитування</summary>

1.  `float my_array[5];`
2.  **0** (нуль).
3.  **6** (елементи нумеруються від 0 до 6).
4.  `my_array[1];`
5.  `my_array[3] = 15.5;`
6.  Це **вихід за межі масиву**, що призведе до **невизначеної поведінки** (undefined behavior).
7.  Це **масив символів (тип `char`)**, який закінчується нуль-термінатором.
8.  **Нуль-термінатор (`'\0'`)**.
9.  `char my_string[] = "Test";`
10. **Розмір масиву** — 3 байти (для 'H', 'i' та '\\0'). **Довжина рядка** — 2.
11. `std::cin`.
12. `std::cin.getline()`.

</details>

-----

## Частина 2: Вирішення задачі "MVP матчу"

**Задача:** Написати програму для визначення "MVP" (Most Valuable Player) у команді з 3 гравців. Програма має запитати нікнейм та кількість "кілів" для кожного, а потім визначити переможця.

### Аналіз та план рішення

Для вирішення цієї задачі нам знадобляться два **паралельні масиви**. Це два масиви однакового розміру, де елементи з однаковим індексом логічно пов'язані між собою.

  * `char nicknames[3][50];` — двовимірний масив для зберігання трьох нікнеймів.
  * `int kills[3];` — одновимірний масив для зберігання "кілів".
    Зв'язок тут простий: дані гравця з індексом `i` зберігаються в `nicknames[i]` та `kills[i]`.

### ❓ Питання до групи (Давайте поміркуємо)

1.  Подивіться на `char nicknames[3][50];`. Чому тут два числа? Що, на вашу думку, означає `[3]` і що означає `[50]`?
2.  Наш план — ініціалізувати `max_kills` та `mvp_index` даними *першого* гравця (`kills[0]`). А чому б не ініціалізувати їх просто нулем (`max_kills = 0`)? Чи спрацює такий підхід? У яких випадках він може дати збій?

<details markdown="1">
<summary>Натисніть, щоб побачити відповіді</summary>

1.  Це **двовимірний масив** (масив масивів). `[3]` означає, що у нас є 3 "рядки" (по одному для кожного гравця). `[50]` означає, що кожен з цих рядків є C-рядком (масивом `char`) довжиною 50 символів (щоб вмістити довгі нікнейми).
2.  Якщо ініціалізувати `max_kills = 0`, це **може дати збій**, якщо всі гравці зіграли дуже погано і мають *негативну* кількість "кілів" (наприклад, у грі є штрафи, і у всіх по -5). Тоді програма невірно скаже, що MVP має 0 "кілів". Ініціалізація першим реальним елементом (`kills[0]`) — це найнадійніший спосіб, який працює *завжди*, для будь-яких чисел (додатних, від'ємних чи нульових).

</details>

### Написання коду

Тепер, коли ми маємо план, давайте напишемо код. Зверніть увагу на коментарі, особливо на `std::cin.ignore()`.

<details markdown="1">
<summary>Натисніть, щоб побачити фінальний код</summary>

```cpp
#include <iostream>
#include <limits> // Для очищення буфера вводу

const int PLAYER_COUNT = 3;
const int NICKNAME_LENGTH = 50;

int main() {
    char nicknames[PLAYER_COUNT][NICKNAME_LENGTH];
    int kills[PLAYER_COUNT];

    // --- Етап А: Введення даних ---
    for (int i = 0; i < PLAYER_COUNT; ++i) {
        std::cout << "Введіть нікнейм гравця " << i + 1 << ": ";
        // Використовуємо getline для зчитування рядка з пробілами
        std::cin.getline(nicknames[i], NICKNAME_LENGTH);

        std::cout << "Введіть кількість кілів для " << nicknames[i] << ": ";
        std::cin >> kills[i];

        // ВАЖЛИВО: Очищуємо буфер вводу після зчитування числа.
        // cin >> kills[i] зчитує число, але залишає в буфері
        // невидимий символ 'Enter' (\n). 
        // Наступний виклик cin.getline() бачить цей \n і думає,
        // що це порожній рядок.
        // Ця команда "з'їдає" всі символи до наступного \n.
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    }

    // --- Етап Б: Пошук MVP ---
    // Ініціалізуємо першим гравцем
    int max_kills = kills[0];
    int mvp_index = 0;

    // Починаємо цикл з 1 (другого гравця), бо 0-го ми вже взяли
    for (int i = 1; i < PLAYER_COUNT; ++i) {
        if (kills[i] > max_kills) {
            max_kills = kills[i];
            mvp_index = i;
        }
    }

    // --- Етап В: Виведення результату ---
    std::cout << "==========================" << std::endl;
    std::cout << "MVP матчу: " << nicknames[mvp_index] << std::endl;
    std::cout << "Кількість кілів: " << max_kills << std::endl;
    std::cout << "==========================" << std::endl;

    return 0;
}
```

</details>

-----

## Частина 3: Контрольні питання

Тепер давайте перевіримо розуміння ключових моментів:

  * **Питання 1:** Чому для нікнеймів ми використали двовимірний масив `char`, а для "кілів" — одновимірний `int`?
  * **Питання 2:** Поясніть своїми словами, що таке "паралельні масиви" і чому індекс `mvp_index` дозволив нам знайти і ім'я, і результат переможця.
  * **Питання 3:** Чому було важливо ініціалізувати `max_kills` саме першим елементом, а не, наприклад, нулем?

<details markdown="1">
<summary>Натисніть, щоб побачити відповіді</summary>

**1. Чому масиви різні?**

  * Для "кілів" нам потрібно зберігати список простих чисел (`int`). Для цього ідеально підходить одновимірний масив `int kills[3]`.
  * Для нікнеймів нам потрібно зберігати список... *рядків*. А кожен C-рядок сам по собі є *масивом символів* (`char`). Тому для зберігання "списку списків символів" нам потрібен двовимірний масив `char nicknames[3][50]`, де `[3]` — це кількість гравців, а `[50]` — максимальна довжина нікнейму кожного з них.

**2. Паралельні масиви та індекс MVP**

  * **Паралельні масиви** — це техніка програмування, коли ми використовуємо два або більше масивів однакової довжини. Дані в них логічно пов'язані **за індексом**. У нашому випадку: `nicknames[0]` — це ім'я гравця, чиї "кіли" знаходяться в `kills[0]`. `nicknames[1]` пов'язаний з `kills[1]` і так далі.
  * Завдяки цьому, коли ми шукали MVP, ми працювали лише з масивом `kills`. Ми знайшли, що найбільше значення знаходиться в індексі `i`. Цей індекс `i` ми зберегли у змінній `mvp_index`. Оскільки масиви паралельні, ми *знаємо*, що нікнейм переможця знаходиться в *тому самому індексі* в іншому масиві: `nicknames[mvp_index]`.

**3. Ініціалізація `max_kills`**

  * Якщо ініціалізувати `max_kills = 0`, наш алгоритм зламається, якщо всі гравці зіграють з від'ємним рахунком (наприклад, -5, -10, -2). У цьому випадку 0 буде найбільшим числом, і програма невірно оголосить MVP з результатом 0, хоча такого гравця не існує.
  * Беручи `max_kills = kills[0]` (значення першого гравця) за "початкового чемпіона", ми гарантуємо, що наш `max_kills` *завжди* буде реальним результатом з нашого списку. Це найнадійніший підхід.

</details>