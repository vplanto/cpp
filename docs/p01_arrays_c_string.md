# Практикум 1: Масиви та C-рядки — Визначаємо MVP матчу

## Частина 1: Експрес-опитування та розминка

Перш ніж писати код, давайте швидко перевіримо ключові поняття з лекції. Спробуйте відповісти на ці питання самостійно, а потім перевірте себе.

1.  Як у C++ оголосити масив для 5 чисел з плаваючою комою?
2.  Який індекс має **перший** елемент будь-якого масиву?
3.  Якщо масив має розмір 7, який індекс має його **останній** елемент?
4.  Як звернутися до другого елемента масиву `my_array`?
5.  Як присвоїти значення `15.5` четвертому елементу масиву `my_array`?
6.  Що станеться, якщо ми спробуємо звернутися до `my_array[7]` у масиві розміром 7?
7.  Чим по суті є C-рядок (C-string)?
8.  Який спеціальний символ завжди стоїть у кінці C-рядка?
9.  Як оголосити та ініціалізувати C-рядок зі словом "Test"?
10. У чому різниця між розміром масиву `char s[] = "Hi";` та довжиною рядка "Hi"?
11. Яка команда використовується для зчитування одного слова з клавіатури?
12. Яка команда використовується для зчитування цілого рядка з пробілами?

<details>
<summary>Натисніть, щоб побачити відповіді на опитування</summary>

1.  `float my_array[5];`
2.  **0** (нуль).
3.  **6** (елементи нумеруються від 0 до 6).
4.  `my_array[1];`
5.  `my_array[3] = 15.5;`
6.  Це **вихід за межі масиву**, що призведе до **невизначеної поведінки** (undefined behavior).
7.  Це **масив символів (тип `char`)**, який закінчується нуль-термінатором.
8.  **Нуль-термінатор (`'\0'`)**.
9.  `char my_string[] = "Test";`
10. **Розмір масиву** — 3 байти (для 'H', 'i' та '\0'). **Довжина рядка** — 2.
11. `std::cin`.
12. `std::cin.getline()`.

</details>

---

## Частина 2: Вирішення задачі "MVP матчу"

**Задача:** Написати програму для визначення "MVP" (Most Valuable Player) у команді з 3 гравців. Програма має запитати нікнейм та кількість "кілів" для кожного, а потім визначити переможця.

### Аналіз та план рішення

Для вирішення цієї задачі нам знадобляться два **паралельні масиви**. Це два масиви однакового розміру, де елементи з однаковим індексом логічно пов'язані між собою.
* `char nicknames[3][50];` — двовимірний масив для зберігання трьох нікнеймів.
* `int kills[3];` — одновимірний масив для зберігання "кілів".
Зв'язок тут простий: дані гравця з індексом `i` зберігаються в `nicknames[i]` та `kills[i]`.

Щоб знайти MVP, нам потрібні ще дві змінні: `int max_kills` для зберігання максимального результату та `int mvp_index` для зберігання індексу найкращого гравця. Правильна стратегія — ініціалізувати їх даними першого гравця, а потім у циклі порівнювати з рештою.

Давайте напишемо код для цього.

<details>
<summary>Натисніть, щоб побачити фінальний код</summary>

```cpp
#include <iostream>
#include <limits> // Для очищення буфера вводу

const int PLAYER_COUNT = 3;
const int NICKNAME_LENGTH = 50;

int main() {
    char nicknames[PLAYER_COUNT][NICKNAME_LENGTH];
    int kills[PLAYER_COUNT];

    // --- Етап А: Введення даних ---
    for (int i = 0; i < PLAYER_COUNT; ++i) {
        std::cout << "Введіть нікнейм гравця " << i + 1 << ": ";
        // Використовуємо getline для зчитування рядка з пробілами
        std::cin.getline(nicknames[i], NICKNAME_LENGTH);

        std::cout << "Введіть кількість кілів для " << nicknames[i] << ": ";
        std::cin >> kills[i];

        // Очищуємо буфер вводу після зчитування числа, щоб getline працював коректно
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    }

    // --- Етап Б: Пошук MVP ---
    int max_kills = kills[0];
    int mvp_index = 0;

    for (int i = 1; i < PLAYER_COUNT; ++i) {
        if (kills[i] > max_kills) {
            max_kills = kills[i];
            mvp_index = i;
        }
    }

    // --- Етап В: Виведення результату ---
    std::cout << "\n==========================" << std::endl;
    std::cout << "MVP матчу: " << nicknames[mvp_index] << std::endl;
    std::cout << "Кількість кілів: " << max_kills << std::endl;
    std::cout << "==========================" << std::endl;

    return 0;
}
````

\</details\>

-----

## Частина 3: Контрольні питання

Тепер давайте перевіримо розуміння ключових моментів:

  * **Питання 1:** Чому для нікнеймів ми використали двовимірний масив `char`, а для "кілів" — одновимірний `int`?
  * **Питання 2:** Поясніть своїми словами, що таке "паралельні масиви" і чому індекс `mvp_index` дозволив нам знайти і ім'я, і результат переможця.
  * **Питання 3:** Чому було важливо ініціалізувати `max_kills` саме першим елементом, а не, наприклад, нулем?