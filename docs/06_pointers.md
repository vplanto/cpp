# Лекція 6: Вказівники (Pointers) в C++

## Що таке вказівник і навіщо він потрібен?

**Вказівники (Pointers)**, **посилання (References)** та **динамічне виділення пам'яті** — це найпотужніші можливості C++, що дозволяють програмісту напряму керувати пам'яттю. Це критично важливо для досягнення максимальної продуктивності.

Водночас, вказівники є однією з найскладніших тем. Роботу з ними влучно описують як **"заряджений пістолет в руках новачка"**:
* **Потужність:** Дозволяють напряму звертатися до комірок пам'яті та змінювати їх вміст.
* **Складність:** Важкі для коректного використання.
* **Ризики:** Неправильне використання призводить до нечитабельного коду, витоків пам'яті, переповнення буфера та вразливостей у безпеці.

Сучасні мови, як-от Java та C#, уникають вказівників на користь автоматичного управління пам'яттю. Однак для C++ розуміння вказівників є фундаментальним.

---

## Пам'ять комп'ютера: Адреси та дані

Щоб зрозуміти вказівники, потрібно уявити пам'ять комп'ютера. Це довга послідовність комірок, кожна розміром в 1 байт.
* Кожна комірка має унікальний числовий номер — **адресу** (зазвичай у шістнадцятковому форматі).
* Кожна комірка зберігає якесь значення — **дані**.

Змінні, які ми створюємо в програмі, розміщуються в цих комірках. Тип даних (`int`, `double`) каже компілятору, скільки байт займати і як інтерпретувати дані в них.

| Комп'ютер | | Програміст | | |
| :--- | :--- | :--- | :--- | :--- |
| **Адреса** | **Вміст (Hex)** | **Ім'я** | **Тип** | **Значення** |
| `0x90000000` | `00` | | | |
| `0x90000001` | `00` | `sum` | `int` (4 байти) | `0x000000FF` (255) |
| `0x90000002` | `00` | | | |
| `0x90000003` | `FF` | | | |
| `0x90000004` | `FF` | `age` | `short` (2 байти) | `0xFFFF` (-1) |
| `0x90000005` | `FF` | | | |
| ... | ... | | | |
| `0x9000000E` | `90` | `ptrSum` | `int*` (4 байти) | `0x90000000` |
| `0x9000000F` | `00` | | | |
| `0x90000010` | `00` | | | |
| `0x90000011` | `00` | | | |

**Вказівник — це змінна, яка зберігає не звичайне значення (як 255), а адресу іншої комірки пам'яті.**

---

## Робота з вказівниками

### Оголошення вказівників

Вказівник оголошується за допомогою символу `*`. Він завжди пов'язаний з певним типом даних.
```cpp
// Синтаксис:
// тип_даних *ім'я_вказівника;

int *iPtr; // iPtr - це вказівник, що може зберігати адресу змінної типу int
double *dPtr; // dPtr - вказівник на double
````

**Дуже важливий нюанс синтаксису при оголошенні кількох змінних:**

```cpp
int* p1, p2; // p1 - це вказівник на int, АЛЕ p2 - це звичайний int!
int *p1, *p2; // Правильно: p1 та p2 - це вказівники на int.
```

**Угода про іменування:** Рекомендується додавати до імені вказівника префікс `p` або суфікс `Ptr` (наприклад, `pNumber`, `numberPtr`).

### Оператор отримання адреси `&`

Щоб отримати адресу існуючої змінної, використовується **оператор `&`**. Результат цієї операції можна присвоїти вказівнику. Може бути тільки RHS оператором.

```cpp
int number = 88;       // Звичайна змінна
int *pNumber;          // Оголошення вказівника
pNumber = &number;     // Присвоєння адреси змінної 'number' вказівнику 'pNumber'

// Можна оголосити та ініціалізувати одразу
int *pAnother = &number;
```

![Оператор отримання адреси](attachments/06_address_of.png)

## LHS та RHS: Ліва та Права сторони операції

У мовах програмування, особливо при роботі з оператором присвоєння (`=`), поняття **LHS (Left-Hand Side)** та **RHS (Right-Hand Side)** є фундаментальними. Вони означають ліву та праву сторони від оператора і мають абсолютно різні ролі та правила.

---

### ### RHS (Права сторона) — Сторона "Значення"

**Роль:** Основна задача правої сторони — **бути обчисленою (evaluated) до єдиного, конкретного значення.** Це сторона, яка "дає" результат.

**Чим може бути RHS:**
* **Літералом:** `x = 10;` (RHS — це число `10`)
* **Змінною:** `x = y;` (RHS — це значення, що зберігається у змінній `y`)
* **Арифметичним виразом:** `x = y + z * 2;` (RHS — це результат обчислення виразу)
* **Викликом функції, що повертає значення:** `x = getArea(5.0);` (RHS — це значення, яке поверне функція `getArea`)

> **Аналогія:** Уявіть, що RHS — це математична задача на дошці. Перш ніж щось робити далі, вам потрібно її розв'язати і отримати одну чітку відповідь.

---

### ### LHS (Ліва сторона) — Сторона "Призначення"

**Роль:** Основна задача лівої сторони — **визначити місце в пам'яті (бути локатором), куди буде збережено результат**, отриманий з правої сторони.

**Чим може бути LHS (в операції присвоєння):**
* **Змінною:** `x = 10;` (LHS — це комірка пам'яті, що асоційована зі змінною `x`)
* **Елементом масиву:** `arr[0] = 20;`
* **Розіменованим вказівником:** `*ptr = 30;`

**Важливо:** LHS не може бути виразом або літералом. Саме тому запис `x + y = 10;` є **некоректним** у програмуванні. Вираз `x + y` обчислюється у значення, але він не є коміркою пам'яті, куди можна щось записати.

> **Аналогія:** Уявіть, що LHS — це поштова скринька з номером. Ви не можете відправити лист "на відповідь задачі 2+2". Ви можете відправити його лише на конкретну адресу, наприклад, "скринька №4".

---

### ## Підсумкова таблиця

| Характеристика | LHS (Ліва сторона) | RHS (Права сторона) |
| :--- | :--- | :--- |
| **Основна роль** | Призначення (Destination / Locator) | Значення (Value / Source) |
| **Що робить?** | Вказує, **куди** зберегти результат. | Обчислюється, **що** саме зберегти. |
| **Приклади** | `myVar`, `myArray[i]`, `*myPtr` | `100`, `anotherVar`, `5 * (x + y)`, `getValue()` |

### Оператор розіменування `*`

Щоб отримати або змінити **значення, що зберігається за адресою**, яку тримає вказівник, використовується **оператор розіменування `*`**.

```cpp
int number = 88;
int *pNumber = &number;

// Вивід інформації
cout << pNumber << endl;  // Виведе адресу змінної number (напр., 0x22ccec)
cout << *pNumber << endl; // Виведе значення, що лежить за цією адресою (88)

// Зміна значення через вказівник
*pNumber = 99; // Записати значення 99 в комірку, на яку вказує pNumber

cout << *pNumber << endl; // Виведе 99
cout << number << endl;   // Значення оригінальної змінної також змінилося на 99
```

-----

## Правила та найчастіші помилки

### Сувора типізація вказівників

Вказівник є строго типізованим. Вказівник на `int` може зберігати лише адресу змінної `int`, вказівник на `double` — лише адресу `double`.

```cpp
int i = 88;
double d = 55.66;
int *iPtr = &i;
// iPtr = &d; // ПОМИЛКА: не можна присвоїти адресу double вказівнику на int
// iPtr = i;  // ПОМИЛКА: вказівник зберігає адресу, а не значення
```

### Неініціалізовані вказівники ("дикі" вказівники)

Оголошення вказівника без ініціалізації є вкрай небезпечним.

```cpp
int *iPtr;   // iPtr вказує на випадкову адресу в пам'яті
*iPtr = 55;  // Запис числа 55 у випадкову комірку!
             // Це може "зламати" інші частини вашої програми або всю систему.
```

Це одна з найсерйозніших помилок, яку компілятор може не виявити.

### Нульові вказівники (Null Pointers)

Щоб уникнути проблеми з "дикими" вказівниками, якщо вказівник ще не вказує на реальний об'єкт, його варто ініціалізувати нульовим значенням.

```cpp
int *iPtr = 0;    // Старий стиль C
int *p = NULL;    // Стиль C, використовує макрос
int *pNew = nullptr; // Сучасний, рекомендований стиль C++11
```

**`nullptr` є кращим вибором**, оскільки він є типізованим і запобігає певним видам помилок.

Спроба розіменувати нульовий вказівник (`*pNew`) призведе до негайного аварійного завершення програми, що набагато краще, ніж тихе пошкодження пам'яті.

-----

## Контрольні питання

1.  **Концепція.** Поясніть різницю між змінною-вказівником та звичайною змінною. Що зберігає кожна з них?

2.  **Синтаксис та аналіз.** Що буде виведено на екран в результаті виконання коду? Поясніть значення `&x`, `ptr` та `*ptr`.

    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        int x = 10;
        int *ptr = &x;
        *ptr = 20;
        
        cout << "Address of x: " << &x << endl;
        cout << "Value of ptr: " << ptr << endl;
        cout << "Value pointed to by ptr: " << *ptr << endl;
        cout << "Value of x: " << x << endl;
        return 0;
    }
    ```

3.  **Помилки.** Знайдіть дві серйозні помилки в цьому коді. Поясніть, чому вони небезпечні.

    ```cpp
    int *pValue;
    *pValue = 100;

    double pi = 3.14;
    pValue = &pi;
    ```

4.  **Застосування.** Оголосіть змінну `double price = 19.99;` та вказівник `pPrice`, який вказує на неї. Потім, використовуючи **лише вказівник `pPrice`**, змініть значення `price` на `24.99`.