# Лекція 4: Розширені можливості типів: приведення, масиви та C-Strings

## Робота з різними типами: приведення та конвертація

У програмах часто доводиться працювати зі змінними різних типів, зокрема `int` та `double`. Хоча `double` може зберігати ціле число, для цілих чисел завжди варто використовувати `int`, оскільки він є значно ефективнішим з точки зору швидкості виконання та використання пам'яті. При змішуванні цих типів потрібно бути дуже уважним.

### Правила арифметичних операцій
* Операція між двома `int` завжди повертає `int`. **(Найчастіша помилка!)**
    ```cpp
    // 1 / 2 -> 0 (дробова частина відкидається)
    ```
* Операція між двома `double` повертає `double`.
    ```cpp
    // 1.0 / 2.0 -> 0.5
    ```
* Операція між `int` та `double` повертає `double`.
    ```cpp
    // 1.0 / 2 -> 0.5
    // 1 / 2.0 -> 0.5
    ```

### Приведення типів (Type Casting)
* **Неявне приведення (Implicit Casting):** При присвоєнні значення `int` змінній типу `double` компілятор автоматично конвертує його.
    ```cpp
    int i = 3;
    double d = i; // d стає 3.0
    ```
* **Втрата точності (Truncation):** При присвоєнні `double` змінній типу `int` дробова частина просто **відкидається** (без округлення).
    ```cpp
    double d = 55.66;
    int i = d; // i стає 55
    ```

---

## Отримання інформації про типи

### Оператор `sizeof`
C++ надає оператор `sizeof` для отримання розміру типу даних або змінної у байтах.
```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Size of int: " << sizeof(int) << " bytes" << endl;
    cout << "Size of double: " << sizeof(double) << " bytes" << endl;
    int arr[10];
    cout << "Size of arr[10]: " << sizeof(arr) << " bytes" << endl;
    return 0;
}
````

### Заголовок `<climits>`

Цей заголовок містить константи, що визначають граничні значення для цілочисельних типів (наприклад, `INT_MAX`, `INT_MIN`).

```cpp
#include <iostream>
#include <climits> // Потрібно підключити для INT_MAX та INT_MIN
using namespace std;

int main() {
    cout << "Max value for int: " << INT_MAX << endl;
    cout << "Min value for int: " << INT_MIN << endl;
    return 0;
}
```

-----

## Масиви (Arrays)

### Навіщо потрібні масиви?

Якщо вам потрібно зберігати оцінки 30 студентів, створювати 30 окремих змінних (`mark1`, `mark2`...) незручно. Замість цього можна використати **масив** — структуру, що зберігає список елементів **одного й того ж типу**.

### Оголошення та ініціалізація

Для оголошення масиву потрібно вказати його тип, ім'я та розмір (кількість елементів).

```cpp
// Оголошення масиву цілих чисел на 5 елементів
int marks[5];

// Оголошення та ініціалізація одночасно
int numbers[3] = {11, 33, 44};

// Якщо розмір не вказано, компілятор порахує кількість елементів
int numbers[] = {11, 33, 44}; // Створиться масив на 3 елементи

// Ініціалізація всіх елементів нулями
int numbers[5] = {0}; // Або int numbers[5] = {};
```

**Важливо:** Після оголошення масиву його розмір змінити не можна.

### Доступ до елементів та індексація

Доступ до елементів масиву відбувається за **індексом** — порядковим номером елемента. **Індексація в C++ починається з нуля\!** Для масиву розміром `n`, індекси будуть від `0` до `n-1`.

![Масив та індекси](attachments/04_arrays.png)

```cpp
int marks[5];      // Індекси від 0 до 4
marks[0] = 100;    // Запис значення в перший елемент
marks[4] = 95;     // Запис значення в останній елемент
cout << marks[0];  // Читання значення
```

### Обробка масивів за допомогою циклів

Масиви та цикли ідеально доповнюють один одного.

```cpp
int scores[] = {8, 7, 9, 10, 6};
int sum = 0;

// Класичний цикл for
for (int i = 0; i < 5; ++i) {
    sum += scores[i];
}

// Range-based for loop (C++11 і новіші)
for (int score : scores) {
    cout << score << " ";
}
```

### Головні недоліки та небезпеки масивів у C++

  * **Фіксований розмір:** Це головний недолік. Ви повинні знати розмір масиву заздалегідь. Для динамічних масивів у сучасному C++ використовують `std::vector`.
  * **Відсутність перевірки меж:** C++ **не перевіряє**, чи ви не вийшли за межі масиву. Звернення до неіснуючого індексу (наприклад, `arr[10]` для масиву розміром 5) не викличе помилку компіляції, але призведе до непередбачуваної поведінки програми та є серйозною загрозою безпеці. Це одна з найнебезпечніших особливостей C/C++.

-----

## Багатовимірні масиви

Масиви можуть бути багатовимірними, наприклад, 2D-масив для представлення матриці або таблиці.

```cpp
// Оголошення та ініціалізація 2D-масиву (2 рядки, 3 стовпці)
int table[2][3] = { {11, 22, 33}, {44, 55, 66} };

// Доступ до елемента: table[рядок][стовпець]
cout << table[0][1]; // Виведе 22
cout << table[1][2]; // Виведе 66
```

Елементи зберігаються "по рядках" (row-major order).

-----

## Масиви символів: C-Strings

У мові C рядки представлялися як масив символів (`char`), що закінчується нульовим символом `\0`. Такі рядки називаються C-Strings.

```cpp
char message[256];
char str1[] = "Hello"; // Компілятор автоматично додасть '\0' в кінці
```

**Рекомендація:** Для початківців (і не тільки) **наполегливо рекомендується уникати C-Strings** і використовувати сучасний, безпечний та зручний клас `std::string` з заголовка `<string>`.

-----

## Контрольні питання

1.  **Приведення типів.** Що буде виведено на екран в результаті виконання наступного коду і чому?
    ```cpp
    double result = 9 / 4;
    cout << result;
    ```
2.  **Масиви.** Що не так з цим кодом? Які потенційні наслідки його виконання у C++?
    ```cpp
    int arr[5] = {1, 2, 3, 4, 5};
    arr[5] = 6;
    cout << arr[5];
    ```
3.  **Застосування.** Напишіть код для обчислення середнього значення елементів масиву `int marks[] = {8, 7, 9, 10, 6};` з використанням будь-якого циклу.
4.  **Концепція.** Назвіть дві основні переваги використання `std::vector` над вбудованими C-style масивами, згадані в лекції.