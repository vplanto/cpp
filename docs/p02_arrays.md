# Практикум 2: Масиви як вектори — Статистика ігрового персонажа

## Вступ

Сьогодні ми заглибимося в роботу з масивами та подивимося, як вони можуть представляти не просто набори чисел, а й математичні вектори. На прикладі створення та аналізу характеристик ігрового персонажа ми розберемо:
* Вивід елементів у прямому та зворотному порядку.
* Базові векторні операції: додавання, скалярний добуток та нормування.

---

## Частина 1: Створення персонажа та вивід характеристик

Уявімо, що наш персонаж має три основні характеристики: **Сила, Спритність, Інтелект**. Зберігати їх будемо в масиві.

```cpp
#include <iostream>
#include <cmath> // для sqrt()
#include <iomanip> // для setprecision()

int main() {
    const int STAT_COUNT = 3;
    int baseStats[STAT_COUNT] = {10, 5, 8}; // Сила=10, Спритність=5, Інтелект=8

    // Вивід у прямому порядку
    std::cout << "Базові характеристики:" << std::endl;
    for (int i = 0; i < STAT_COUNT; ++i) {
        std::cout << baseStats[i] << " ";
    }
    std::cout << std::endl;
```

### Вивід елементів у зворотному порядку

Існує два популярних способи це зробити:

**Спосіб 1: Цикл від `n-1` до `0`**
Найбільш інтуїтивний спосіб. Ми просто починаємо цикл з останнього індексу і рухаємося до першого.

```cpp
    // Спосіб 1: цикл від кінця до початку
    std::cout << "Характеристики у зворотному порядку (спосіб 1):" << std::endl;
    for (int i = STAT_COUNT - 1; i >= 0; --i) {
        std::cout << baseStats[i] << " ";
    }
    std::cout << std::endl;
```

**Спосіб 2: Цикл від `0` до `n`, але зі зміненим індексом**
Ми використовуємо стандартний цикл, але для доступу до елементів обчислюємо індекс "дзеркально" відносно кінця масиву.

```cpp
    // Спосіб 2: "дзеркальний" індекс
    std::cout << "Характеристики у зворотному порядку (спосіб 2):" << std::endl;
    for (int i = 0; i < STAT_COUNT; ++i) {
        // Коли i=0, індекс буде 3-1-0=2 (останній)
        // Коли i=1, індекс буде 3-1-1=1 (середній)
        // Коли i=2, індекс буде 3-1-2=0 (перший)
        std::cout << baseStats[STAT_COUNT - 1 - i] << " ";
    }
    std::cout << std::endl;
}
```

-----

## Частина 2: Масиви як вектори — Операції зі статистикою

Тепер давайте виконаємо кілька "векторних" операцій над нашими характеристиками.

### Додавання векторів: Екіпірування предмету

**Задача:** Наш персонаж знаходить "Амулет Сили", який дає `+2` до Сили та `+1` до Інтелекту. Потрібно обчислити нові, загальні характеристики.

**Рішення:** Створюємо "вектор" характеристик амулета і додаємо його до базового вектора.

```cpp
    // ... продовження коду ...
    int amuletStats[STAT_COUNT] = {2, 0, 1}; // +2 Сили, +0 Спритності, +1 Інтелекту
    int totalStats[STAT_COUNT];

    for (int i = 0; i < STAT_COUNT; ++i) {
        totalStats[i] = baseStats[i] + amuletStats[i];
    }

    std::cout << "Характеристики з амулетом:" << std::endl;
    for (int i = 0; i < STAT_COUNT; ++i) {
        std::cout << totalStats[i] << " "; // Очікуваний результат: 12 5 9
    }
    std::cout << std::endl;
```

### Скалярний добуток: Розрахунок "спорідненості" зі зброєю

**Задача:** Персонаж хоче взяти "Посох Мага". Ефективність посоха залежить від характеристик персонажа. Формула ефективності: `(Сила * 0) + (Спритність * 1) + (Інтелект * 3)`. Нам потрібно обчислити цей показник. Це і є **скалярний добуток** вектора характеристик персонажа та вектора "вимог" зброї.

**Рішення:** Створюємо вектор вимог і поелементно перемножуємо його з вектором характеристик, додаючи результати.

```cpp
    // ... продовження коду ...
    int staffRequirements[STAT_COUNT] = {0, 1, 3}; // Коефіцієнти для скалярного добутку
    int affinityScore = 0;

    for (int i = 0; i < STAT_COUNT; ++i) {
        affinityScore += totalStats[i] * staffRequirements[i];
    }
    
    // Розрахунок: (12 * 0) + (5 * 1) + (9 * 3) = 0 + 5 + 27 = 32
    std::cout << "Рейтинг спорідненості з посохом: " << affinityScore << std::endl;
```

### Нормування вектора: Визначення "білду" персонажа

**Задача:** Ми хочемо зрозуміти "спеціалізацію" нашого персонажа — наскільки він "воїн", "лучник" чи "маг" — у вигляді вектора, де сума квадратів компонент дорівнює 1. Це називається **нормуванням**.

**Рішення:**

1.  Обчислити довжину (модуль) вектора за формулою: `sqrt(x² + y² + z²)`.
2.  Розділити кожну компоненту вектора на його довжину.

<!-- end list -->

```cpp
    // ... продовження коду ...
    double sumOfSquares = 0;
    for (int i = 0; i < STAT_COUNT; ++i) {
        sumOfSquares += totalStats[i] * totalStats[i];
    }
    double magnitude = sqrt(sumOfSquares); // Довжина вектора

    double normalizedStats[STAT_COUNT];
    for (int i = 0; i < STAT_COUNT; ++i) {
        normalizedStats[i] = totalStats[i] / magnitude;
    }

    std::cout << "Нормований вектор 'білду':" << std::endl;
    std::cout << std::fixed << std::setprecision(2); // Встановлюємо точність виводу
    for (int i = 0; i < STAT_COUNT; ++i) {
        std::cout << normalizedStats[i] << " "; // Показує розподіл характеристик
    }
    std::cout << std::endl;
```

Високе перше значення вказує на схильність до "воїна", третє — до "мага".

-----

## Контрольні питання

1.  **Вивід масиву.** Опишіть своїми словами логіку розрахунку індексу `STAT_COUNT - 1 - i`. Чому він дозволяє вивести масив у зворотному порядку?
2.  **Векторні операції.** У вас є два масиви, що представляють вектори `A` та `B`. Яку операцію (додавання чи скалярний добуток) ви використаєте, щоб отримати новий вектор `C`? А щоб отримати єдине число?
3.  **Нормування.** Який перший крок потрібно зробити перед тим, як нормувати вектор (масив)? З якої бібліотеки потрібно підключити функцію для цього кроку?
4.  **Практична задача.** Уявіть, що у вас є масив `prices[5]`, що містить ціни 5 товарів. На всі товари діє знижка 10%. Напишіть фрагмент коду, який створить новий масив `discountedPrices` з оновленими цінами.

-----

## Фінальний код (всі частини разом)

<details>
<summary>Натисніть, щоб побачити повний код</summary>

```cpp
#include <iostream>
#include <cmath> // для sqrt()
#include <iomanip> // для setprecision()

int main() {
    const int STAT_COUNT = 3;
    int baseStats[STAT_COUNT] = {10, 5, 8}; // Сила=10, Спритність=5, Інтелект=8

    // --- Частина 1: Вивід характеристик ---
    std::cout << "Базові характеристики:" << std::endl;
    for (int i = 0; i < STAT_COUNT; ++i) {
        std::cout << baseStats[i] << " ";
    }
    std::cout << std::endl;

    // Спосіб 1: цикл від кінця до початку
    std::cout << "Характеристики у зворотному порядку (спосіб 1):" << std::endl;
    for (int i = STAT_COUNT - 1; i >= 0; --i) {
        std::cout << baseStats[i] << " ";
    }
    std::cout << std::endl;

    // Спосіб 2: "дзеркальний" індекс
    std::cout << "Характеристики у зворотному порядку (спосіб 2):" << std::endl;
    for (int i = 0; i < STAT_COUNT; ++i) {
        std::cout << baseStats[STAT_COUNT - 1 - i] << " ";
    }
    std::cout << std::endl;

    // --- Частина 2: Векторні операції ---

    // Додавання векторів
    int amuletStats[STAT_COUNT] = {2, 0, 1}; // +2 Сили, +0 Спритності, +1 Інтелекту
    int totalStats[STAT_COUNT];

    for (int i = 0; i < STAT_COUNT; ++i) {
        totalStats[i] = baseStats[i] + amuletStats[i];
    }

    std::cout << "Характеристики з амулетом:" << std::endl;
    for (int i = 0; i < STAT_COUNT; ++i) {
        std::cout << totalStats[i] << " "; // Очікуваний результат: 12 5 9
    }
    std::cout << std::endl;

    // Скалярний добуток
    int staffRequirements[STAT_COUNT] = {0, 1, 3}; // Коефіцієнти
    int affinityScore = 0;

    for (int i = 0; i < STAT_COUNT; ++i) {
        affinityScore += totalStats[i] * staffRequirements[i];
    }
    std::cout << "Рейтинг спорідненості з посохом: " << affinityScore << std::endl;

    // Нормування вектора
    double sumOfSquares = 0;
    for (int i = 0; i < STAT_COUNT; ++i) {
        sumOfSquares += totalStats[i] * totalStats[i];
    }
    double magnitude = sqrt(sumOfSquares); // Довжина вектора

    double normalizedStats[STAT_COUNT];
    for (int i = 0; i < STAT_COUNT; ++i) {
        normalizedStats[i] = totalStats[i] / magnitude;
    }

    std::cout << "Нормований вектор 'білду':" << std::endl;
    std::cout << std::fixed << std::setprecision(2); // Встановлюємо точність виводу
    for (int i = 0; i < STAT_COUNT; ++i) {
        std::cout << normalizedStats[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

</details>