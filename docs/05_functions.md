# Лекція 5: Функції в C++

## Навіщо потрібні функції?

Часто певні ділянки коду потрібно використовувати багато разів у різних місцях програми. Замість того, щоб копіювати один і той самий код, що ускладнює його підтримку, краще винести цей код в окремий блок, який називається **функцією** (або підпрограмою), і викликати його за потребою.

**Основні переваги використання функцій:**
* **"Розділяй та володарюй" (Divide and Conquer):** Дозволяє розбити велику складну програму на менші, простіші та незалежні компоненти. Це робить програму модульною.
* **Уникнення повторення коду (DRY - Don't Repeat Yourself):** Легко скопіювати, але важко підтримувати та синхронізувати всі копії. Функції вирішують цю проблему.
* **Повторне використання коду (Software Reuse):** Ви можете використовувати написані вами функції в інших програмах, об'єднуючи їх у бібліотеки.

---

## Анатомія функції

У взаємодії з функцією завжди беруть участь дві сторони: **той, хто викликає (caller)**, і **функція, яку викликають (called function)**. Процес виглядає так:
1.  **Caller** викликає функцію, передаючи їй необхідні дані — **аргументи**.
2.  **Функція** отримує ці дані у свої **параметри**, виконує закладені в неї операції.
3.  Після завершення роботи функція повертає **результат** назад до **caller-а**.

![Виклик функції](attachments/05_call_function.png)

### Визначення функції (Function Definition)
Це повний опис того, що робить функція.
```cpp
// Синтаксис:
// тип_повернення ім'я_функції ( список_параметрів ) {
//     тіло_функції;
// }

// Приклад:
double getArea(double r) {
    return r * r * 3.14159265;
}
```

  * **`returnValueType`:** Тип даних, який функція повертає (наприклад, `int`, `double`). Якщо функція нічого не повертає, використовується тип `void`.
  * **`parameterList`:** Список параметрів, які функція приймає, у форматі `тип1 ім'я1, тип2 ім'я2, ...`.

### Прототип функції (Function Prototype)

У C++ функція має бути оголошена **до** її першого виклику. Це можна зробити, розмістивши її повне визначення вище по коду, або за допомогою **прототипу**. Прототип — це лише заголовок функції, що повідомляє компілятору про її інтерфейс.

```cpp
// Прототипи функцій
double getArea(double);
int max(int, int);

// ... інший код, наприклад, функція main(), яка їх викликає ...

// Повні визначення функцій можна розмістити нижче
double getArea(double r) { /* ... */ }
int max(int a, int b) { /* ... */ }
```

Прототипи зазвичай розміщують у заголовочних файлах (`.h`), щоб їх можна було підключати до різних частин програми.

### Оператор `return` та тип `void`

  * **`return`**: Використовується для повернення результату з функції та передачі керування назад у точку виклику.
  * **`void`**: Використовується для функцій, які виконують дії, але не повертають значення (наприклад, функція, що просто друкує щось на екран). У таких функціях `return;` можна використовувати для дострокового виходу, але він не є обов'язковим.

-----

## Параметри та стек викликів

  * **Формальні параметри (Formal Parameters):** Це змінні, оголошені у заголовку функції (наприклад, `double r` у `getArea(double r)`). Вони існують лише всередині функції.
  * **Фактичні параметри (Actual Parameters / Arguments):** Це реальні значення або змінні, які передаються у функцію під час її виклику (наприклад, `radius1` у `getArea(radius1)`).

### Стек викликів (Call Stack)

Стек викликів — це спеціальна область пам'яті, яка зберігає інформацію про активні функції. Коли одна функція викликає іншу, для нової функції створюється **фрейм стеку (stack frame)**, який розміщується на вершині стеку. Цей фрейм містить параметри функції, її локальні змінні та адресу повернення (куди повернутися після завершення). Коли функція завершує роботу, її фрейм видаляється зі стеку.

![Стек викликів](attachments/05_function_call_stack.png)

-----

## Область видимості змінних (Scope)

Область видимості визначає, де саме у програмі доступна та чи інша змінна.

#### Локальна область видимості (Local Scope)

  * **Визначення:** Змінні, оголошені всередині функції.
  * **Видимість:** Тільки всередині цієї функції.
  * **Час життя:** Створюються при виклику функції, знищуються при виході з неї.

#### Глобальна область видимості (Global Scope)

  * **Визначення:** Змінні, оголошені поза будь-якими функціями.
  * **Видимість:** Доступні з будь-якої частини коду після їх оголошення.
  * **Час життя:** Існують протягом усього часу виконання програми.
  * **Рекомендація:** **Уникайте використання глобальних змінних\!** Вони ускладнюють відстеження логіки та можуть призводити до непередбачуваних побічних ефектів.

#### Блочна область видимості (Block Scope)

  * **Визначення:** Змінні, оголошені всередині блоку коду (`{...}`).
  * **Видимість:** Тільки всередині цього блоку.
  * **Час життя:** Створюються при вході в блок, знищуються при виході з нього.

-----

## Розширені можливості функцій C++

### Аргументи за замовчуванням (Default Arguments)

C++ дозволяє задавати значення за замовчуванням для параметрів функції. Такі параметри можна не передавати при виклику.

```cpp
// Прототип з аргументом за замовчуванням
void greet(string name = "Guest");

greet();       // Виведе "Hello, Guest!"
greet("Alice");  // Виведе "Hello, Alice!"
```

**Правило:** Аргументи за замовчуванням мають бути вказані **справа наліво**.

### Вбудовані функції (Inline Functions)

Для дуже маленьких функцій, що часто викликаються, можна використовувати ключове слово `inline`. Це **рекомендація** для компілятора — замість реального виклику функції підставити її код прямо в місце виклику, щоб зменшити накладні витрати.

```cpp
inline int square(int x) {
    return x * x;
}
```

**Важливо:** Компілятор може проігнорувати цю рекомендацію.

### Лямбда-функції (Lambda Functions, C++11)

Це анонімні (безіменні) функції, які можна визначати прямо "на місці". Вони дуже корисні для коротких операцій, що передаються як аргументи в інші функції.

```cpp
// Лямбда-функція, що додає два числа
auto add = [](int a, int b) -> int {
    return a + b;
};

cout << add(3, 4); // Виведе 7
```

### Рекурсивні функції

**Рекурсія** — це техніка, при якій функція викликає саму себе для вирішення задачі.

```cpp
// Класичний приклад - обчислення факторіалу
int factorial(int n) {
    if (n <= 1) {
        return 1; // Базовий випадок, що зупиняє рекурсію
    } else {
        return n * factorial(n - 1); // Рекурсивний виклик
    }
}
```

-----

## Контрольні питання

1.  **Концепція.** Поясніть різницю між прототипом функції та її визначенням. Чому в C++ прототипи є важливими?
2.  **Область видимості.** Що буде виведено на екран? Поясніть свою відповідь, посилаючись на правила області видимості змінних.
    ```cpp
    #include <iostream>
    using namespace std;

    int x = 10; // Глобальна змінна

    void myFunction() {
        int x = 20; // Локальна змінна
        cout << x << endl;
    }

    int main() {
        myFunction();
        cout << x << endl;
        return 0;
    }
    ```
3.  **Застосування.** Напишіть функцію `double average(int a, int b)` та її прототип. Функція має приймати два цілих числа і повертати їхнє середнє арифметичне у вигляді дійсного числа.
4.  **Розширені можливості.** Що таке вбудована (inline) функція і в яких випадках її доцільно використовувати? Чи є директива `inline` обов'язковою для виконання компілятором?