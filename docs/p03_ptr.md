# Практикум 3: Вказівники — Керуємо пам'яттю як профі

## Вступ

Сьогодні ми розберемо один з найпотужніших, але й найскладніших інструментів C++ — **вказівники (pointers)**. Правильне їх використання є ключем до написання швидкого та ефективного коду, особливо в ігровій розробці.

Ми будемо вчитися на практичному прикладі: напишемо програму для аналізу списку рекордів у грі, щоб зрозуміти, навіщо нам потрібен доступ не просто до значень, а до їх **розташування в пам'яті**.

---

## Частина 1: Проблема — нам потрібна не тільки відповідь, а й місце

Уявімо, що у нас є масив, який зберігає рекорди гравців за 5 раундів гри.
```cpp
int gameScores[5] = {8500, 9200, 7800, 9800, 9100};
````

**Задача:** Написати функцію, яка знаходить найкращий результат.

Давайте напишемо просту версію, яка повертає лише значення.

```cpp
int findMaxScore(int scores[], int size) {
    int maxScore = scores[0];
    for (int i = 1; i < size; ++i) {
        if (scores[i] > maxScore) {
            maxScore = scores[i];
        }
    }
    return maxScore;
}
```

**Питання до групи:** "Ми викликали цю функцію і отримали відповідь `9800`. Все чудово. Але що ми втратили? Ми знаємо, *який* рекорд найкращий, але не знаємо, *де* він знаходиться (в якому раунді). Як нам, наприклад, нарахувати бонус за цей рекорд, змінивши його в оригінальному масиві?"

**Проблема:** Функція, що повертає лише значення, не дає нам доступу до **оригінальної комірки пам'яті**. Нам потрібен інструмент, який може вказувати на **місце**, а не на значення.

-----

## Частина 2: Вказівники — "закладки" в пам'яті

**Вказівник (`*`)** — це змінна, яка зберігає не звичайне значення (як `9800`), а **адресу в пам'яті** іншої змінної.

Уявіть пам'ять як довгу вулицю з будинками.

  * **Звичайна змінна (`int x = 10;`)** — це **вміст** будинку.
  * **Вказівник (`int* p;`)** — це **записка з адресою** цього будинку.

### Два головні оператори

1.  **Оператор отримання адреси (`&`)** — "Дай мені адресу цієї змінної".
    ```cpp
    int score = 100;
    int* pScore = &score; // pScore тепер зберігає адресу змінної score
    ```
2.  **Оператор розіменування (`*`)** — "Покажи, що лежить за адресою, записаною в цьому вказівнику".
    ```cpp
    std::cout << *pScore; // Виведе 100 - значення, що лежить за адресою
    *pScore = 150;        // Змінюємо значення за адресою. Тепер score = 150
    ```

-----

## Частина 3: Вирішуємо нашу задачу за допомогою вказівників

Давайте перепишемо нашу функцію так, щоб вона повертала **вказівник** на комірку з максимальним значенням.

```cpp
#include <iostream>

// Функція тепер повертає вказівник на int (адресу)
int* findBestScorePtr(int scores[], int size) {
    // Перевірка, чи масив не порожній
    if (size <= 0) {
        return nullptr; // Повертаємо нульовий вказівник, якщо даних немає
    }

    // Створюємо вказівник, який буде "закладкою" на найкращий результат
    int* pBestScore = &scores[0]; // Починаємо з припущення, що перший елемент - найкращий

    // Шукаємо кращий результат
    for (int i = 1; i < size; ++i) {
        // Порівнюємо ЗНАЧЕННЯ поточного елемента зі ЗНАЧЕННЯМ, на яке вказує наша "закладка"
        if (scores[i] > *pBestScore) {
            // Якщо знайшли кращий, переставляємо "закладку" на нову адресу
            pBestScore = &scores[i];
        }
    }

    return pBestScore;
}
```

Тепер подивимося, як це використовувати:

```cpp
int main() {
    int gameScores[5] = {8500, 9200, 7800, 9800, 9100};

    // Отримуємо не значення, а вказівник на найкращий результат
    int* pChampionScore = findBestScorePtr(gameScores, 5);

    if (pChampionScore != nullptr) {
        std::cout << "Найкращий результат: " << *pChampionScore << std::endl;

        // Тепер ми можемо змінити оригінальний масив через вказівник!
        std::cout << "Нараховуємо бонус +100..." << std::endl;
        *pChampionScore += 100;
    }

    // Виведемо весь масив, щоб побачити зміни
    std::cout << "Оновлені результати раундів:" << std::endl;
    for (int i = 0; i < 5; ++i) {
        std::cout << gameScores[i] << " "; // Виведе: 8500 9200 7800 9900 9100
    }
    std::cout << std::endl;

    return 0;
}
```

Ми не тільки знайшли найкращий результат, але й змогли його змінити, знаючи його **розташування**.

-----

## Частина 4: Правила безпеки

1.  **Неініціалізовані ("дикі") вказівники:** `int* p; *p = 10;` — це катастрофа. Вказівник `p` вказує на випадкову адресу, і ви записуєте `10` у невідому частину пам'яті.
2.  **Нульові вказівники (`nullptr`):** Якщо вказівник поки що ні на що не вказує, ініціалізуйте його `nullptr`. Це безпечно.
    ```cpp
    int* p = nullptr;
    // if (p != nullptr) { *p = 20; } // Завжди перевіряйте перед розіменуванням!
    ```
    Спроба розіменувати `nullptr` призведе до падіння програми, що набагато краще, ніж тихе пошкодження даних.

-----

## Контрольні питання

1.  **Концепція.** Поясніть своїми словами, що зберігає змінна-вказівник? Чим це відрізняється від звичайної змінної `int`?
2.  **Синтаксис.** Який оператор використовується, щоб отримати **адресу** змінної? А який — щоб отримати **значення**, що лежить за адресою, збереженою у вказівнику?
3.  **Аналіз коду.** Що буде виведено на екран в результаті виконання наступного коду?
    ```cpp
    int a = 50;
    int* pA = &a;
    *pA = 100;
    std::cout << a << std::endl;
    ```
4.  **Вибір.** Вам потрібно написати функцію, яка може "провалитися" і не знайти потрібний елемент у масиві. Що краще повернути в цьому випадку: `0`, `-1` чи `nullptr`? Чому?