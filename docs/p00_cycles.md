# Практикум 0: Вирішення перших задач та цикли

## Вступ

Сьогодні ми розберемось у базовому робочому процесу для вирішення алгоритмічних задач. Цей процес завжди складається з двох ключових етапів:
1.  **Розуміння та планування:** Спочатку ми уважно читаємо умову, визначаємо, які дані нам потрібні, якого вони будуть типу, і що ми маємо отримати в результаті.
2.  **Написання коду:** Тільки після того, як у нас є чіткий план, ми перетворюємо його на код.

Ми розберемо дві прості задачі, щоб відпрацювати цей підхід.

---

## Задача 1: Сума, мінімум та максимум елементів

**Умова:** Дано послідовність з `n` дійсних чисел. Знайти суму, макс і мін всіх її елементів.
* **Вхідні дані:** У першому рядку записано число `n` (`n` ≤ 100). У наступному рядку записано `n` дійсних чисел, кожне не перевищує 100 за модулем.
* **Вихідні дані:** Вивести суму, мінімальний та максимальний елементи послідовності.

### Крок 1: Розуміння задачі та планування рішення

1.  **Змінні для вхідних даних:**
    * Нам потрібно зчитати кількість елементів. Оскільки `n` не перевищує 100, для цього ідеально підійде тип **`int`**. Назвемо змінну `n`.
    * Далі нам потрібно зчитати `n` дійсних чисел. Чи потрібно зберігати їх усі одночасно в масиві? Ні, оскільки задача просить знайти лише суму, мінімум та максимум. Ми можемо читати числа по одному і одразу їх обробляти. Це більш ефективно з точки зору використання пам'яті. Для зберігання кожного поточного числа нам знадобиться тимчасова змінна. Оскільки числа "дійсні" (з дробовою частиною), її тип має бути **`double`**. Назвемо її `currentNumber`.

2.  **Змінні для результатів:**
    * Нам потрібні три змінні для зберігання результатів:
        * `double sum` для суми.
        * `double min_val` для мінімального значення.
        * `double max_val` для максимального значення.

3.  **Алгоритм та ініціалізація (важливий момент):**
    * Щоб коректно знайти мінімум та максимум, ми не можемо ініціалізувати `min_val` та `max_val` нулем. Якщо всі числа будуть, наприклад, додатними, мінімум залишиться 0, що невірно.
    * **Правильний підхід:** Зчитати **перший** елемент послідовності до початку циклу та ініціалізувати ним **всі три** змінні (`sum`, `min_val`, `max_val`).
    * Після цього запустити цикл, який повториться `n-1` разів (для решти елементів).
    * Всередині циклу: зчитувати наступне число, додавати його до `sum`, і порівнювати з поточними `min_val` та `max_val`, оновлюючи їх у разі потреби.
    * Після циклу вивести всі три результати.

### Крок 2: Написання коду

<details>
<summary>Натисніть, щоб побачити рішення</summary>

```cpp
#include <iostream>
#include <iomanip> // Для форматування виводу

int main() {
    // Встановлюємо фіксовану точність для виводу дійсних чисел
    std::cout << std::fixed << std::setprecision(1);

    int n;
    std::cin >> n;

    // Обробка випадку, коли послідовність може бути порожньою
    if (n <= 0) {
        std::cout << "Послідовність порожня." << std::endl;
        return 0;
    }

    double first_number;
    std::cin >> first_number;

    // Ініціалізуємо всі змінні першим елементом послідовності
    double sum = first_number;
    double min_val = first_number;
    double max_val = first_number;

    // Цикл для решти n-1 елементів
    for (int i = 1; i < n; ++i) {
        double current_number;
        std::cin >> current_number;

        // Оновлюємо суму
        sum += current_number;

        // Перевіряємо та оновлюємо мінімум
        if (current_number < min_val) {
            min_val = current_number;
        }

        // Перевіряємо та оновлюємо максимум
        if (current_number > max_val) {
            max_val = current_number;
        }
    }

    // Виводимо результати
    std::cout << "Сума: " << sum << std::endl;
    std::cout << "Мінімум: " << min_val << std::endl;
    std::cout << "Максимум: " << max_val << std::endl;

    return 0;
}
```

</details>

-----

## Задача 2: Факторіал

**Умова:** Обчисліть факторіал числа `n`.

  * **Вхідні дані:** Одне число `n` (0 ≤ `n` ≤ 20).
  * **Вихідні дані:** Вивести значення `n!`.

### Крок 1: Розуміння задачі та планування рішення

1.  **Змінна для вхідних даних:**

      * Нам потрібно зчитати одне ціле число `n`. Оскільки `n` не перевищує 20, тип **`int`** цілком підходить.

2.  **Змінна для результату:**
      * Факторіал — це добуток чисел. Давайте оцінимо максимальне можливе значення. `20!` — це дуже велике число (`2,432,902,008,176,640,000`).
      * Тип `int` (≈ 2 млрд) не підходить.
      * Тип `long long` (≈ 9 \* 10^18) **теж не підходить**, бо `20!` більше.
      * Тип **`unsigned long long`** (≈ 1.8 \* 10^19) — **єдиний стандартний цілочисельний тип, який може вмістити цей результат**. Це ключовий момент у цій задачі.
      * Назвемо змінну `factorial` і ініціалізуємо її `1`, оскільки факторіал `0!` дорівнює `1`, і це початкове значення для множення.


**_NOTE:_** як дізнатись про типи? Читати офіційну документацію - https://en.cppreference.com/w/cpp/language/types.html

3.  **Алгоритм:**

      * Зчитати `n`.
      * Запустити цикл від 1 до `n`.
      * Всередині циклу множити поточне значення `factorial` на лічильник циклу.
      * Після циклу вивести результат.

### Крок 2: Написання коду

<details>
<summary>Натисніть, щоб побачити рішення</summary>

```cpp
#include <iostream>

int main() {
    // 1. Оголошуємо змінні
    int n;
    // ОБОВ'ЯЗКОВО використовуємо unsigned long long, щоб уникнути переповнення
    unsigned long long factorial = 1;

    // Зчитуємо n
    std::cin >> n;

    // 2. Цикл для обчислення добутку від 1 до n
    // Якщо n = 0, цикл не виконається, і factorial залишиться 1, що є правильним.
    for (int i = 1; i <= n; ++i) {
        factorial *= i;
    }

    // 3. Виводимо результат
    std::cout << factorial << std::endl;

    return 0;
}
```

</details>

-----

## Контрольні питання

1.  **Ефективність.** У першій задачі, чому ми не стали зберігати всі введені числа в масиві? В якому випадку використання масиву було б необхідним?
2.  **Типи даних.** У другій задачі, що сталося б, якби ми використали тип `long long` замість `unsigned long long` для зберігання факторіалу числа 20?
3.  **Алгоритми.** Як би ви змінили код першої задачі, щоб він, окрім суми, мінімуму та максимуму, знаходив також **середнє арифметичне** елементів послідовності?