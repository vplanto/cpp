# Лекція 7: Посилання (References) та передача параметрів у функції

## Що таке посилання (Reference)?

**Посилання (Reference)**, яке з'явилося в C++, — це **псевдонім (alias)** або альтернативне ім'я для вже існуючої змінної. Після створення посилання, ви можете звертатися до однієї і тієї ж комірки пам'яті, використовуючи як оригінальне ім'я, так і ім'я-псевдонім.

![Посилання](attachments/07_reference.png)

Основне призначення посилань — використання в якості параметрів функцій для реалізації механізму **передачі за посиланням (pass-by-reference)**.

### Подвійне значення символу `&`
Символ `&` в C++ має два значення залежно від контексту:
* **В виразах:** Це оператор **отримання адреси**. `&number` повертає адресу змінної `number`.
* **В оголошеннях:** Це частина ідентифікатора типу, що створює **посилання**. `int &refNumber = number;` створює посилання `refNumber` на змінну `number`.

**Синтаксис оголошення:**
```cpp
// newName стає новим ім'ям (псевдонімом) для existingName
type &newName = existingName;
```

Внутрішньо посилання працює подібно до вказівника: воно зберігає адресу змінної, на яку посилається.

![Як працюють посилання](attachments/07_how_reference_work.png)

-----

## Посилання проти вказівників

Хоча посилання та вказівники схожі, між ними є принципові відмінності, що роблять посилання простішими та безпечнішими у використанні.

| Критерій | Вказівник (`*`) | Посилання (`&`) |
| :--- | :--- | :--- |
| **Ініціалізація** | Може бути неініціалізованим (вказувати будь-куди). Можна ініціалізувати `nullptr`. | **Обов'язково** має бути ініціалізоване існуючою змінною в момент оголошення. |
| **Зміна цілі** | Може бути перенаправлений на іншу змінну в будь-який момент. | **Не може бути змінене.** Завжди посилається на ту саму змінну, з якою було ініціалізоване. |
| **Синтаксис доступу** | Потребує **явного розіменування** за допомогою оператора `*` (`*pNumber = 10;`). | Розіменовується **неявно**. Використовується як звичайна змінна (`refNumber = 10;`). |
| **Null-значення** | Може бути нульовим (`nullptr`), тобто не вказувати на жодну змінну. | **Не може бути `null`**. Завжди має посилатися на валідну змінну. |

-----

## Передача параметрів у функції

Це ключове застосування посилань. Існує три основні способи передачі параметрів у функцію:

#### 1\. За значенням (Pass-by-Value)

  * **Що відбувається:** У функцію передається **копія** аргументу.
  * **Ефект:** Усі зміни всередині функції відбуваються з локальною копією і **не впливають** на оригінальну змінну.
  * **Приклад:** `void func(int x);`

#### 2\. За вказівником (Pass-by-Pointer)

  * **Що відбувається:** У функцію передається **адреса** змінної (копія вказівника).
  * **Ефект:** Функція може змінювати оригінальну змінну, розіменовуючи вказівник.
  * **Синтаксис:** Вимагає `*` та `&` у коді, що робить його менш читабельним.
  * **Приклад:** `void func(int* x);`

#### 3\. За посиланням (Pass-by-Reference)

  * **Що відбувається:** У функцію передається **псевдонім** оригінальної змінної.
  * **Ефект:** Функція працює **безпосередньо з оригінальною змінною**. Усі зміни впливають на неї.
  * **Синтаксис:** Чистий та інтуїтивний, як при передачі за значенням.
  * **Приклад:** `void func(int& x);`

-----

## Безпека та ефективність: `const` у параметрах

Ключове слово `const` у поєднанні з посиланнями є потужним інструментом.

**Синтаксис:** `void func(const string& str);`

**Переваги:**

1.  **Ефективність:** Дозволяє передавати у функцію великі об'єкти (як `string` або структури) **без дорогого копіювання**, як при передачі за значенням.
2.  **Безпека:** Гарантує, що функція **не зможе випадково змінити** оригінальний об'єкт. Це робить код надійнішим.

> **Золоте правило:** Якщо функція не повинна змінювати вхідний параметр-об'єкт, завжди передавайте його як **константне посилання (`const &`)**.

-----

## Повернення значень за посиланням

Функції також можуть повертати значення за посиланням (`int& func()`). Це дозволяє, наприклад, використовувати виклик функції з лівого боку від оператора присвоєння.

#### ⚠️ Критична помилка: Повернення посилання на локальну змінну

**Ніколи не повертайте посилання на локальну змінну функції\!**

```cpp
// ПОГАНИЙ КОД - НЕ РОБІТЬ ТАК!
int& badFunction() {
    int localVar = 10;
    return localVar; // Повернення посилання на змінну, яка буде знищена
}

int main() {
    int& ref = badFunction();
    // ref тепер є "висячим" посиланням, що вказує на сміття в пам'яті.
    // Подальше використання ref призведе до непередбачуваної поведінки.
}
```

Локальні змінні знищуються після виходу з функції, і посилання стає "висячим", вказуючи на невалідну область пам'яті.

-----

## Контрольні питання

1.  **Концепція.** Назвіть дві ключові відмінності між вказівником та посиланням в C++.
2.  **Застосування.** Що таке "передача за посиланням" (pass-by-reference)? Які переваги вона дає порівняно з "передачею за значенням" (pass-by-value), особливо при роботі з великими об'єктами?
3.  **Аналіз коду.** Знайдіть критичну логічну помилку в наступній функції. Поясніть, чому цей код небезпечний.
    ```cpp
    int& getSomeValue() {
        int temp = 5;
        // ... якісь обчислення ...
        return temp;
    }
    ```
4.  **Синтаксис.** Напишіть прототип функції `processUserData`, яка приймає великий об'єкт `string` на ім'я `userData` для читання (без права на зміну) та цілочисельну змінну `errorCounter`, яку вона повинна мати змогу змінювати. Використовуйте найефективніший та найбезпечніший спосіб передачі параметрів.