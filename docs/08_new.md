# Лекція 8: Динамічне управління пам'яттю та розширені можливості вказівників

## Динамічне виділення пам'яті: `new` та `delete`

Досі ми працювали зі **статичним виділенням пам'яті**: компілятор сам визначав, скільки пам'яті потрібно для змінних, і автоматично звільняв її. **Динамічне виділення пам'яті** дозволяє програмісту запитувати пам'ять під час виконання програми (в runtime). Це дає повний контроль, але й накладає повну відповідальність.

Для цього в C++ використовуються оператори `new` та `delete`, які працюють з вказівниками.
* **`new`**: Запитує блок пам'яті з "купи" (heap) і повертає вказівник на початок цього блоку.
* **`delete`**: Повертає блок пам'яті, раніше виділений через `new`, назад у систему.

```cpp
// Статичне виділення
int number = 88;
int *p1 = &number;

// Динамічне виділення
int *p2 = new int;    // Виділити пам'ять для одного int і записати адресу в p2
*p2 = 99;             // Записати значення 99 у виділену комірку

cout << "Value: " << *p2 << endl; // Виведе 99

delete p2;            // Звільнити виділену пам'ять. ВАЖЛИВО!
````

**Ініціалізація при виділенні:**

```cpp
// Ініціалізація фундаментального типу
int *p1 = new int(88);
double *p2 = new double{1.23}; // C++11 синтаксис

// Ініціалізація об'єкта (виклик конструктора)
Date *date1 = new Date(1999, 1, 1);
```

**Ключове правило:** Пам'ять, виділена за допомогою `new` всередині функції, **не звільняється автоматично** після виходу з неї. Якщо ви не викличете `delete`, відбудеться **витік пам'яті (memory leak)**.

-----

## Динамічні масиви: `new[]` та `delete[]`

Динамічно можна виділяти пам'ять і для масивів, розмір яких може бути визначений під час виконання програми.

  * **`new T[size]`**: Виділяє пам'ять для масиву з `size` елементів типу `T`.
  * **`delete[]`**: **Обов'язково** використовується для звільнення пам'яті, виділеної через `new[]`.

<!-- end list -->

```cpp
int size;
cout << "Enter array size: ";
cin >> size;

int *arr = new int[size]; // Виділення пам'яті для масиву

arr[0] = 10;
arr[1] = 20;
// ...

delete[] arr; // Звільнення пам'яті масиву
```

**Важливо:** Використання `delete` замість `delete[]` для масиву є серйозною помилкою, що призводить до невизначеної поведінки.

-----

## Масиви та вказівники: Глибокий зв'язок

У C++ ім'я масиву по суті є **вказівником на його перший елемент**.

```cpp
int numbers[] = {10, 20, 30};
// numbers є еквівалентом &numbers[0]
```

Це відкриває можливість **вказівникової арифметики**.

### Вказівникова арифметика

Коли ви додаєте `1` до вказівника, його адреса збільшується не на 1 байт, а на розмір типу даних, на який він вказує.

```cpp
int numbers[] = {11, 22, 33};
int *iPtr = numbers;

cout << iPtr << endl;      // Напр., 0x1000
cout << iPtr + 1 << endl;  // Виведе 0x1004 (адреса + sizeof(int))
cout << *iPtr << endl;     // 11
cout << *(iPtr + 1) << endl; // 22 (еквівалент numbers[1])
```

### Передача масивів у функції

Масив завжди передається у функцію **за посиланням** (насправді, передається вказівник на його перший елемент).

  * Зміни, зроблені всередині функції, **впливають на оригінальний масив**.
  * Розмір масиву втрачається, тому його потрібно передавати окремим параметром.
  * У сигнатурі функції `void func(int arr[])` та `void func(int* arr)` є еквівалентними.

-----

## Керування доступом: `const` та вказівники

Ключове слово `const` може застосовуватися як до даних, на які вказує вказівник, так і до самого вказівника.

> **Мнемонічне правило:** Читайте оголошення **справа наліво**.

  * **`const int * ptr`** (вказівник на `const int`):
      * `*ptr` є константою. **Значення** за вказівником міняти не можна.
      * `ptr` не є константою. **Вказівник** можна перенаправити на іншу адресу.
  * **`int * const ptr`** (константний вказівник на `int`):
      * `*ptr` не є константою. **Значення** за вказівником міняти можна.
      * `ptr` є константою. **Вказівник** не можна перенаправити.
  * **`const int * const ptr`** (константний вказівник на `const int`):
      * **Ні значення, ні вказівник** міняти не можна.

-----

## Спеціалізовані типи вказівників

  * **Вказівники на функції (Function Pointers):** Ім'я функції є її адресою в пам'яті. Можна створити вказівник, що зберігатиме цю адресу, і викликати функцію через нього. Це основа для реалізації колбеків та поліморфізму в стилі C.
  * **Узагальнені вказівники (`void*`):** Вказівник типу `void*` може зберігати адресу змінної **будь-якого типу**. Його не можна розіменувати напряму; перед використанням його потрібно явно привести до конкретного типу вказівника.

-----

## Сучасна практика: Розумні вказівники (Smart Pointers)

Ручне управління пам'яттю за допомогою `new` та `delete` є джерелом багатьох помилок (витоки пам'яті, подвійне звільнення). Сучасний C++ (починаючи з C++11) пропонує краще рішення — **розумні вказівники** з заголовка `<memory>`.

Вони автоматично звільняють пам'ять, коли об'єкт більше не потрібен, дотримуючись принципу **RAII (Resource Acquisition Is Initialization)**.

  * **`std::unique_ptr`**: Унікальне володіння. Пам'ять автоматично звільняється, коли `unique_ptr` виходить з області видимості. Копіювати такий вказівник не можна, лише переміщати.
  * **`std::shared_ptr`**: Спільне володіння. Пам'ять звільняється, коли останній `shared_ptr`, що вказує на об'єкт, знищується.
  * **`std::weak_ptr`**: "Слабке" посилання на об'єкт, керований `shared_ptr`. Не впливає на лічильник посилань і допомагає розривати циклічні залежності.

> **Золоте правило сучасного C++:** Віддавайте перевагу розумним вказівникам над сирими (`new`/`delete`) для управління динамічною пам'яттю.

-----

## Контрольні питання

1.  **Управління пам'яттю.** Що таке "витік пам'яті" (memory leak)? Яка пара операторів у C++ використовується для ручного управління динамічною пам'яттю, і яка помилка в їх використанні призводить до витоків?
2.  **Вказівникова арифметика.** Що виведе наступний код, якщо адреса `arr` дорівнює `0x1000`, а `sizeof(int)` дорівнює 4?
    ```cpp
    int arr[] = {10, 20, 30};
    int* p = arr;
    cout << *(p + 1) << endl;
    cout << (p + 1) << endl;
    ```
3.  **`const` та вказівники.** Поясніть різницю між `const int* ptr` та `int* const ptr`. Наведіть приклади операцій, які будуть дозволені та заборонені для кожного з них.
4.  **Застосування.** Напишіть функцію, яка динамічно створює масив цілих чисел заданого розміру (`size`), заповнює його квадратами чисел від 0 до `size-1` і повертає вказівник на цей масив.