# Практикум 4: Вказівники та Посилання — Керуємо ігровим світом

## Вступ

Сьогодні ми розберемо два найпотужніші інструменти C++ для роботи з пам'яттю: **посилання (references)** та **вказівники (pointers)**. Замість того, щоб просто повторювати теорію, ми будемо вирішувати практичні задачі з розробки гри. Наша мета — зрозуміти, **коли і навіщо** використовувати кожен з цих інструментів.

---

## Частина 1: Проблема ефективності — "Тільки подивитись"

**Задача:** Уявімо, що нам потрібно написати функцію, яка просто **показує** характеристики гравця (здоров'я, ману, досвід), але не змінює їх.

Давайте подивимось на три способи це зробити.
```cpp
// Змінні, що описують нашого гравця
int health = 100;
int mana = 50;
int experience = 12500;

// Спосіб 1: Pass-by-Value (Передача за значенням)
void displayStatsByValue(int h, int m, int e) {
    // Функція отримує КОПІЇ змінних
    std::cout << "HP: " << h << ", MP: " << m << ", EXP: " << e << std::endl;
}

// Спосіб 2: Pass-by-Reference (Передача за посиланням)
void displayStatsByRef(int& h, int& m, int& e) {
    // Функція отримує ПСЕВДОНІМИ оригінальних змінних
    std::cout << "HP: " << h << ", MP: " << m << ", EXP: " << e << std::endl;
}
```

**Питання:** "Уявіть, що замість `int` ми передаємо величезний масив, що описує інвентар гравця. Який з цих двох способів буде працювати швидше і чому?"

  * **Міркуємо разом:** `Pass-by-value` змушує комп'ютер щоразу створювати повну копію всіх даних. Це повільно та неефективно. `Pass-by-reference` не створює копій, а дає прямий доступ, що набагато швидше.

**Виникає інша проблема:** функція, що приймає посилання, може випадково змінити оригінальні дані\!

```cpp
// ... всередині displayStatsByRef ...
h = 0; // Ой! Ми випадково "вбили" гравця, хоча хотіли лише подивитись.
```

**Рішення:** `const` посилання — найкращий друг програміста.

```cpp
// Спосіб 3: Pass-by-const-Reference (Найкращий варіант)
void displayStatsByConstRef(const int& h, const int& m, const int& e) {
    std::cout << "HP: " << h << ", MP: " << m << ", EXP: " << e << std::endl;
    // h = 0; // ПОМИЛКА КОМПІЛЯЦІЇ! Код захищений від випадкових змін.
}
```

> **Висновок 1:** Для передачі "важких" даних, які функція має **тільки читати**, завжди використовуйте **константні посилання (`const &`)**. Це швидко і безпечно.

-----

## Частина 2: Проблема модифікації — "Треба змінити"

**Задача:** Тепер нам потрібна функція для торгівлі, яка **має змінювати** баланс золота двох гравців.

```cpp
int player1Gold = 500;
int player2Gold = 200;
```

**Питання:** "Спираючись на попередній приклад, який спосіб передачі параметрів нам тут потрібен і чому?"

  * **Міркуємо разом:** Нам потрібен доступ до оригінальних змінних, щоб їх змінити. Отже, нам підходять або звичайні посилання, або вказівники. Посилання тут виглядають простішими та безпечнішими.

Давайте напишемо функцію торгівлі.

```cpp
// Функція приймає посилання і гарантовано змінює оригінали
void trade(int& p1Gold, int& p2Gold, int amount) {
    p1Gold -= amount;
    p2Gold += amount;
}

// ... у main ...
trade(player1Gold, player2Gold, 100);
// Тепер player1Gold = 400, player2Gold = 300
```

> **Висновок 2:** Для зміни параметрів, які **обов'язково мають існувати**, використовуйте **звичайні посилання (`&`)**.

-----

## Частина 3: Проблема опціональності — "Можливо, змінимо"

**Задача:** Напишемо функцію, що накладає на гравця позитивний ефект ("баф"). Функція збільшує основну характеристику гравця (наприклад, силу), але **опціонально** може збільшити і другорядну (наприклад, витривалість).

**Питання:** "Як нам передати у функцію другорядну характеристику, якої може і не бути? Чи можемо ми використати посилання?"

  * **Міркуємо разом:** Посилання **не може** бути "порожнім" (`null`). Воно завжди має вказувати на існуючу змінну. Отже, для опціонального параметра воно не підходить. Тут нам на допомогу приходять **вказівники**.

**Вказівник** — це змінна, яка зберігає **адресу** іншої змінної. Його головна перевага — він може бути `nullptr`, тобто "ні на що не вказувати".

```cpp
void applyBuff(int& mainStat, int* optionalStat) {
    mainStat += 10; // Змінюємо основну характеристику через посилання

    // Перевіряємо, чи нам взагалі передали другорядну характеристику
    if (optionalStat != nullptr) {
        *optionalStat += 5; // Змінюємо її через вказівник
    }
}

int main() {
    int strength = 20;
    int endurance = 15;

    // Випадок 1: Бафаємо обидві характеристики
    applyBuff(strength, &endurance); // strength=30, endurance=20

    // Випадок 2: Бафаємо тільки основну
    applyBuff(strength, nullptr); // strength=40, endurance не змінюється
}
```

> **Висновок 3:** Для зміни параметрів, які можуть бути **відсутніми (опціональними)**, використовуйте **вказівники (`*`)**.

-----

## Частина 4: Критична помилка — "Повернення в нікуди"

**Задача:** Давайте напишемо функцію, яка знаходить, у кого з двох гравців менше здоров'я, і повертає "ручку" (handle), щоб ми могли його вилікувати.

```cpp
// Функція повертає посилання на змінну з меншим значенням
int& findLowerHealth(int& p1Health, int& p2Health) {
    return (p1Health < p2Health) ? p1Health : p2Health;
}

int main() {
    int p1Health = 50;
    int p2Health = 80;

    // Отримуємо посилання на p1Health і лікуємо його
    findLowerHealth(p1Health, p2Health) = 100;
    // Тепер p1Health = 100
}
```

**Питання:** "Здається, все працює. А що станеться, якщо ми спробуємо повернути посилання на змінну, створену **всередині** функції?"

```cpp
// ДУЖЕ ПОГАНИЙ КОД!
int& createBonus() {
    int bonus = 100;
    return bonus; // Помилка! 'bonus' буде знищено після виходу з функції
}
```

  * **Міркуємо разом:** Локальна змінна `bonus` існує лише всередині `createBonus()`. Коли функція завершується, пам'ять, де вона знаходилась, звільняється. Посилання, яке ми повернули, стає "висячим" — воно вказує на сміття.
  * **Аналогія:** Це як записати адресу готельного номера, з якого ви вже виїхали. Адреса існує, але хто там тепер живе — невідомо.

> **Висновок 4:** **Ніколи** не повертайте посилання або вказівник на локальну змінну.

-----

## Контрольні питання

1.  **Проблема.** Поясніть своїми словами, чому функція `tradeByValue` не змогла змінити баланс гравців.
2.  **Посилання.** У вас є функція, яка має **тільки читати** ім'я гравця (великий C-рядок), не змінюючи його. Як ви оголосите її параметр, щоб це було і ефективно, і безпечно?
3.  **Вказівники.** Який оператор використовується, щоб отримати **адресу** змінної? А який — щоб отримати **значення**, що лежить за адресою, збереженою у вказівнику?
4.  **Вибір.** Вам потрібно написати функцію, яка може опціонально застосувати бонус до здоров'я гравця (тобто, параметр здоров'я може бути переданий, а може й ні). Що ви оберете для параметра: посилання чи вказівник? Чому?
5.  **Безпека.** Чому код `int& a = createBonus();` є небезпечним?