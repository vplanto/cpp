# Лекція 2: Що таке програма? Змінні та потік керування

## Програма як послідовність дій

У своїй основі, **програма** — це послідовність інструкцій (програмних операторів), які виконуються одна за одною, зазвичай у тому порядку, в якому вони написані. Це називається **послідовним виконанням**.

![Послідовне виконання програми](attachments/02_statements.png)

Кожна дія, від простого обчислення до виводу на екран, є окремим оператором у цій послідовності. Чудовим прикладом такої програми є обчислення параметрів кола, де кожен крок виконується суворо по черзі.

* **Приклад коду:** [circle_computation.cpp](00-intro/circle_computation.cpp)

***

## Змінні — Пам'ять програми

Комп'ютерні програми маніпулюють даними. **Змінна** — це іменована комірка в пам'яті, яка використовується для зберігання даних під час роботи програми. Вона називається "змінною", тому що її значення можна змінювати.

Кожна змінна має три основні характеристики:
1.  **Ім'я (Name):** Унікальний ідентифікатор для доступу до даних (наприклад, `radius`, `sum`, `userName`).
2.  **Тип (Type):** Визначає, які дані можуть зберігатися у змінній (наприклад, `int` для цілих чисел, `double` для дійсних). Типізація допомагає компілятору правильно інтерпретувати дані.
3.  **Значення (Value):** Конкретні дані, що зберігаються у змінній в даний момент.

![Характеристики змінної](attachments/02_variable.png)

### Оголошення та ініціалізація змінних

Перед використанням змінну потрібно **оголосити**, вказавши її тип та ім'я. Це можна зробити з ініціалізацією (наданням початкового значення) або без неї.

```cpp
// Синтаксис: Оголошення однієї змінної
// var-type var-name;
int sum;
double radius;

// Синтаксис: Оголошення кількох змінних одного типу через кому
// var-type var-name-1, var-name-2, ...;
int product, difference, quotient;

// Синтаксис: Оголошення з одночасною ініціалізацією
// var-type var-name = initial-value;
double pi = 3.14159;
int firstNumber = 1, secondNumber = 2; // Ініціалізація списком
````

### Присвоєння та зміна значення

Після оголошення змінній можна надавати нові значення за допомогою **оператора присвоєння (`=`)**.

```cpp
int number;      // Оголошення
number = 99;     // Перше присвоєння
number = 88;     // Повторне присвоєння (старе значення 99 втрачається)
number = number + 1; // Обчислити вираз справа (88 + 1) і записати результат назад у змінну
```

**Ключові правила роботи зі змінними:**

  * Змінна має бути оголошена **перед її першим використанням**.
  * Кожна змінна може бути оголошена лише **один раз** в одній області видимості.
  * Тип змінної **не можна змінити** після оголошення.
  * Змінна може зберігати значення **лише свого типу**.
    > **Приклад:** Якщо змінна `sum` має тип `int`, спроба присвоїти `sum = 55.66;` призведе до попередження і втрати дробової частини (в `sum` запишеться `55`), а спроба `sum = "Hello";` викличе помилку компіляції.
  * Дуже важливо: Кожен оператор оголошення чи присвоєння в C++ має завершуватися **крапкою з комою (`;`)**.

-----

## Операції зі змінними

### Присвоєння (`=`) — це не рівність (`==`)

Вкрай важливо розрізняти оператор присвоєння в програмуванні та знак рівності в математиці.

  * В математиці `x = x + 1` — це хибне твердження.
  * В програмуванні `x = x + 1;` — це команда: "обчислити значення `x + 1` і записати новий результат назад у змінну `x`".

Завжди спочатку обчислюється вираз **справа** від знака `=`, і лише потім результат записується у змінну **зліва**. Тому запис `x + y = 1;` в C++ є некоректним, бо зліва має бути лише ім'я змінної.

### Арифметичні операції

| Оператор | Значення | Приклад |
| :--- | :--- | :--- |
| `+` | Додавання | `x + y` |
| `-` | Віднімання | `x - y` |
| `*` | Множення | `x * y` |
| `/` | Ділення | `x / y` |
| `%` | Остача від ділення | `x % y` |
| `++` | Збільшити на 1 | `++x` або `x++` |
| `--` | Зменшити на 1 | `--x` або `x--` |

-----

## Керування потоком виконання

Програми не завжди виконуються лінійно. Часто потрібно приймати рішення або повторювати дії. Для цього існують **керуючі конструкції**.

### Умови (if-else)

Умовні оператори дозволяють програмі виконувати різні блоки коду залежно від того, чи є певна умова істинною (`true`) чи хибною (`false`).

```cpp
// Проста умова if
if (number > 0) {
    // цей код виконається, тільки якщо number > 0
    std::cout << "Число додатне";
}

// Умова з альтернативою if-else
if (number % 2 == 0) {
    // цей блок, якщо число парне
    std::cout << "Число парне";
} else {
    // цей блок, якщо число непарне
    std::cout << "Число непарне";
}
```

Для побудови умов використовуються **оператори порівняння** та **логічні оператори**.

| Оператор | Опис | Приклад (`a=10, b=5`) |
| :--- | :--- | :--- |
| `>` | Більше ніж | `a > b` (true) |
| `<` | Менше ніж | `a < b` (false) |
| `>=` | Більше або дорівнює | `a >= 10` (true) |
| `<=` | Менше або дорівнює | `b <= 4` (false) |
| `==` | Дорівнює (порівняння) | `a == b` (false) |
| `!=` | Не дорівнює | `a != b` (true) |

| Оператор | Опис | Приклад (`a=10, b=5`) |
| :--- | :--- | :--- |
| `&&` | Логічне "І" | `(a > 0) && (b == 5)` (true) |
| `\|\|` | Логічне "АБО" | `(a > 10) \|\| (b == 5)` (true) |
| `!` | Логічне "НЕ" | `!(b == 5)` (false) |

Як приклад, розгляньте програму, що підсумовує парні та непарні числа окремо, використовуючи оператор `%` та умову `if-else`.

  * **Приклад коду:** [sum\_odd\_even.cpp](00-intro/sum_odd_even.cpp)

### Цикли (Loops)

#### Приклад: Сума чисел та історія про Гаусса

Існує відома історія про молодого Карла Гаусса, якому вчитель дав завдання додати всі числа від 1 до 100, щоб зайняти клас надовго. Гаусс майже миттєво знайшов відповідь (5050), помітивши, що сума пар чисел (1+100, 2+99, ...) завжди дорівнює 101. Це ілюструє силу **алгоритмічного мислення** — замість того, щоб виконувати тисячі операцій, можна знайти елегантніше рішення.

У програмуванні ми часто починаємо з простого рішення "в лоб" за допомогою циклів, а потім шукаємо шляхи його оптимізації.

Ця програма демонструє, як використати цикл для простого підсумовування чисел від 1 до вказаної межі.

  * **Приклад коду:** [sum\_numbers.cpp](00-intro/sum_numbers.cpp)

Цикли дозволяють виконувати один і той самий блок коду багато разів.

#### Цикл `while`

Цикл `while` ("поки") виконує тіло циклу доти, доки його умова є істинною. Перевірка умови відбувається **перед** кожною ітерацією.

#### Цикл `for`

Цикл `for` є більш структурованою формою циклу і часто використовується, коли кількість повторень відома заздалегідь. Він поєднує в собі три частини: ініціалізацію лічильника, умову продовження та оновлення лічильника після кожної ітерації.

### Три кити програмування: Повнота за Тьюрінгом

Тепер, коли ми знаємо про три основні структури керування:

1.  **Послідовне виконання** (одна команда за одною)
2.  **Розгалуження** (умови `if-else`)
3.  **Цикли** (`while`, `for`)

Варто знати, що цього набору **достатньо для реалізації будь-якого, наскільки завгодно складного, алгоритму**.

Мова програмування, що має ці три структури, називається **повною за Тьюрінгом**. Це означає, що вона може симулювати роботу **машини Тьюрінга** — простої абстрактної математичної моделі обчислювальної машини, яка є теоретичною основою для всіх сучасних комп'ютерів.

-----

## Контрольні питання

1.  **Теорія.** У чому полягає фундаментальна різниця між оператором присвоєння (`=`) та оператором порівняння (`==`) в C++? Наведіть приклад коду, де використання одного замість іншого призведе до логічної помилки.

2.  **Аналіз коду.** Що буде виведено на екран в результаті виконання наступного коду? Покроково поясніть, як змінюється значення змінної `result` протягом виконання циклу.

    ```cpp
    #include <iostream>

    int main() {
        int result = 0;
        for (int i = 1; i <= 10; i++) {
            if (i % 3 == 0) {
                result = result + i;
            }
        }
        std::cout << result << std::endl;
        return 0;
    }
    ```

3.  **Практичне завдання.** Напишіть програму, яка знаходить суму всіх **непарних** чисел від 1 до 100 включно. Використайте для цього цикл `for` та умовний оператор `if`. Результат (суму) виведіть на екран.