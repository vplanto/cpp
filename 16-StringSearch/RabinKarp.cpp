#include <bits/stdc++.h> // Включення більшості стандартних бібліотек
using namespace std;

// Константа d для хеш-функції (кількість символів в алфавіті)
#define d 11

// Функція пошуку патерну pat у тексті txt за допомогою алгоритму Rabin-Karp
// Використовує хешування для швидкого порівняння підрядків
// Складність: O(N + M) у середньому, O(N * M) у найгіршому випадку (багато колізій)
// q - просте число для модульної арифметики (зменшує колізії)
void search(char pat[], char txt[], int q) {
  int M = strlen(pat); // Довжина патерну
  int N = strlen(txt); // Довжина тексту
  int i, j;
  int p = 0; // Хеш-значення для патерну
  int t = 0; // Хеш-значення для тексту
  int h = 1; // Змінна для обчислення d^(M-1) mod q

  // Обчислення значення h = d^(M-1) mod q
  // Використовується для оновлення хешу при зсуві вікна
  for (i = 0; i < M - 1; i++)
    h = (h * d) % q;

  // Обчислення початкових хеш-значень для патерну та першого підрядка тексту довжини M
  for (i = 0; i < M; i++) {
    p = (d * p + pat[i]) % q;  // Хеш патерну
    t = (d * t + txt[i]) % q;  // Хеш першого підрядка тексту
  }

  // Прохід по всіх підрядках тексту довжини M
  for (i = 0; i <= N - M; i++) {
    // Якщо хеш-значення патерну та поточного підрядка співпадають
    if (p == t) {
      // Перевірка, чи справді рядки співпадають (захист від колізій хешу)
      for (j = 0; j < M; j++) {
        if (txt[i + j] != pat[j])
          break;  // Невідповідність - вихід з циклу
      }

      // Якщо рядки справді співпадають, виводимо індекс
      if (j == M)
        cout << "Pattern found at index " << i << endl;
    }

    // Якщо є ще підрядки для перевірки
    if (i < N - M) {
      // Оновлення хеш-значення для наступного підрядка тексту
      // Видаляємо старий символ, додаємо новий (rolling hash)
      t = (d * (t - txt[i] * h) + txt[i + M]) % q;

      // Якщо хеш-значення від'ємне, робимо його додатним
      if (t < 0)
        t = (t + q);
    }
  }
}

int main() {
  char txt[] = "GEEKS FOR GEEKS"; // Текст
  char pat[] = "GEEK";            // Патерн
  int q = 101;                     // Просте число для модульної арифметики
  search(pat, txt, q);            // Виклик функції пошуку
  return 0;
}
