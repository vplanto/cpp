#include <bits/stdc++.h> // Включення більшості стандартних бібліотек
using namespace std;

// Попереднє оголошення функції для обчислення масиву найдовшого власного префікса,
// який також є власним суфіксом (LPS - Longest Proper Prefix which is also Suffix)
void computeLPSArray(char *pat, int M, int *lps);

// Функція пошуку патерну pat у тексті txt за допомогою алгоритму KMP (Knuth-Morris-Pratt)
// Складність: O(N + M) - лінійна складність завдяки використанню LPS масиву
// Переваги: не повертається назад у тексті, використовує інформацію про попередні порівняння
void KMPSearch(char *pat, char *txt) {
  int M = strlen(pat); // Довжина патерну
  int N = strlen(txt); // Довжина тексту

  int lps[M]; // Масив для зберігання значень найдовшого префікса-суфікса для патерну

  computeLPSArray(pat, M, lps); // Заповнення lps[] для заданого патерну

  int i = 0;      // Індекс для txt[]
  int j = 0;      // Індекс для pat[]
  while (i < N) { // Прохід по тексту
    if (pat[j] == txt[i]) { // Якщо поточні символи співпадають
      j++;
      i++;
    }

    if (j == M) { // Якщо знайдено збіг
      printf("Found pattern at index %d \n", i - j);
      j = lps[j - 1]; // Отримання наступного стану патерну з масиву lps[]
                      // Пропуск вже перевірених символів
    }

    else if (i < N && pat[j] != txt[i]) { // Невідповідність після j збігів
      if (j != 0) // Якщо j не 0, починаємо з наступного символу в патерні
        j = lps[j - 1];  // Використання LPS для пропуску непотрібних порівнянь
      else // Якщо j = 0, починаємо з наступного символу в тексті
        i = i + 1;
    }
  }
}

// Функція обчислення масиву найдовшого власного префікса, який також є власним суфіксом
// LPS допомагає KMP алгоритму не повертатися назад у тексті
void computeLPSArray(char *pat, int M, int *lps) {
  int len = 0; // Довжина попереднього найдовшого префікса-суфікса

  lps[0] = 0; // lps[0] завжди 0

  int i = 1; // Змінна циклу
  // Цикл обчислює lps[i] для i = 1 до M-1
  while (i < M) {
    if (pat[i] == pat[len]) { // Якщо pat[i] == pat[len], збільшуємо len та присвоюємо lps[i]
      len++;
      lps[i] = len;
      i++;
    } else {          // Якщо pat[i] != pat[len]
      if (len != 0) { // Якщо len не 0, повертаємося до попереднього символу
        len = lps[len - 1];  // Використання вже обчислених значень
      } else { // Якщо len = 0, присвоюємо lps[i] = 0 та переходимо до наступного символу
        lps[i] = 0;
        i++;
      }
    }
  }
}

int main() {
  char txt[] = "ABABDABACDABABCABAB"; // Текст
  char pat[] = "ABABCABAB";           // Патерн
  KMPSearch(pat, txt); // Виклик функції KMPSearch з патерном та текстом
  return 0;
}
